// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/Newscatcher/newscatcher-go/internal"
)

type SourcesGetRequest struct {
	Lang                  string `json:"-" url:"lang"`
	Countries             string `json:"-" url:"countries"`
	PredefinedSources     string `json:"-" url:"predefined_sources"`
	IncludeAdditionalInfo *bool  `json:"-" url:"include_additional_info,omitempty"`
	FromRank              *int   `json:"-" url:"from_rank,omitempty"`
	ToRank                *int   `json:"-" url:"to_rank,omitempty"`
	SourceName            string `json:"-" url:"source_name"`
	SourceUrl             string `json:"-" url:"source_url"`
	IsNewsDomain          *bool  `json:"-" url:"is_news_domain,omitempty"`
	NewsDomainType        string `json:"-" url:"news_domain_type"`
	NewsType              string `json:"-" url:"news_type"`
}

type SourcesRequest struct {
	Lang                  interface{} `json:"lang,omitempty" url:"-"`
	Countries             interface{} `json:"countries,omitempty" url:"-"`
	PredefinedSources     interface{} `json:"predefined_sources,omitempty" url:"-"`
	IncludeAdditionalInfo *bool       `json:"include_additional_info,omitempty" url:"-"`
	FromRank              *int        `json:"from_rank,omitempty" url:"-"`
	ToRank                *int        `json:"to_rank,omitempty" url:"-"`
	SourceName            interface{} `json:"source_name,omitempty" url:"-"`
	SourceUrl             interface{} `json:"source_url,omitempty" url:"-"`
	IsNewsDomain          *bool       `json:"is_news_domain,omitempty" url:"-"`
	NewsDomainType        interface{} `json:"news_domain_type,omitempty" url:"-"`
	NewsType              interface{} `json:"news_type,omitempty" url:"-"`
}

// AdditionalSourceInfo DTO class.
type AdditionalSourceInfo struct {
	NbArticlesFor7D *int    `json:"nb_articles_for_7d,omitempty" url:"nb_articles_for_7d,omitempty"`
	Country         *string `json:"country,omitempty" url:"country,omitempty"`
	Rank            *int    `json:"rank,omitempty" url:"rank,omitempty"`
	IsNewsDomain    *bool   `json:"is_news_domain,omitempty" url:"is_news_domain,omitempty"`
	NewsDomainType  *string `json:"news_domain_type,omitempty" url:"news_domain_type,omitempty"`
	NewsType        *string `json:"news_type,omitempty" url:"news_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AdditionalSourceInfo) GetNbArticlesFor7D() *int {
	if a == nil {
		return nil
	}
	return a.NbArticlesFor7D
}

func (a *AdditionalSourceInfo) GetCountry() *string {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *AdditionalSourceInfo) GetRank() *int {
	if a == nil {
		return nil
	}
	return a.Rank
}

func (a *AdditionalSourceInfo) GetIsNewsDomain() *bool {
	if a == nil {
		return nil
	}
	return a.IsNewsDomain
}

func (a *AdditionalSourceInfo) GetNewsDomainType() *string {
	if a == nil {
		return nil
	}
	return a.NewsDomainType
}

func (a *AdditionalSourceInfo) GetNewsType() *string {
	if a == nil {
		return nil
	}
	return a.NewsType
}

func (a *AdditionalSourceInfo) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalSourceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalSourceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalSourceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdditionalSourceInfo) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// "SourceInfo DTO class.
type SourceInfo struct {
	NameSource     *string               `json:"name_source,omitempty" url:"name_source,omitempty"`
	DomainUrl      string                `json:"domain_url" url:"domain_url"`
	Logo           *string               `json:"logo,omitempty" url:"logo,omitempty"`
	AdditionalInfo *AdditionalSourceInfo `json:"additional_info,omitempty" url:"additional_info,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceInfo) GetNameSource() *string {
	if s == nil {
		return nil
	}
	return s.NameSource
}

func (s *SourceInfo) GetDomainUrl() string {
	if s == nil {
		return ""
	}
	return s.DomainUrl
}

func (s *SourceInfo) GetLogo() *string {
	if s == nil {
		return nil
	}
	return s.Logo
}

func (s *SourceInfo) GetAdditionalInfo() *AdditionalSourceInfo {
	if s == nil {
		return nil
	}
	return s.AdditionalInfo
}

func (s *SourceInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// SourceResponse DTO class.
type SourceResponse struct {
	Message   string                       `json:"message" url:"message"`
	Sources   []*SourceResponseSourcesItem `json:"sources,omitempty" url:"sources,omitempty"`
	UserInput map[string]interface{}       `json:"user_input,omitempty" url:"user_input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceResponse) GetMessage() string {
	if s == nil {
		return ""
	}
	return s.Message
}

func (s *SourceResponse) GetSources() []*SourceResponseSourcesItem {
	if s == nil {
		return nil
	}
	return s.Sources
}

func (s *SourceResponse) GetUserInput() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.UserInput
}

func (s *SourceResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceResponseSourcesItem struct {
	SourceInfo *SourceInfo
	String     string

	typ string
}

func NewSourceResponseSourcesItemFromSourceInfo(value *SourceInfo) *SourceResponseSourcesItem {
	return &SourceResponseSourcesItem{typ: "SourceInfo", SourceInfo: value}
}

func NewSourceResponseSourcesItemFromString(value string) *SourceResponseSourcesItem {
	return &SourceResponseSourcesItem{typ: "String", String: value}
}

func (s *SourceResponseSourcesItem) GetSourceInfo() *SourceInfo {
	if s == nil {
		return nil
	}
	return s.SourceInfo
}

func (s *SourceResponseSourcesItem) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SourceResponseSourcesItem) UnmarshalJSON(data []byte) error {
	valueSourceInfo := new(SourceInfo)
	if err := json.Unmarshal(data, &valueSourceInfo); err == nil {
		s.typ = "SourceInfo"
		s.SourceInfo = valueSourceInfo
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SourceResponseSourcesItem) MarshalJSON() ([]byte, error) {
	if s.typ == "SourceInfo" || s.SourceInfo != nil {
		return json.Marshal(s.SourceInfo)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SourceResponseSourcesItemVisitor interface {
	VisitSourceInfo(*SourceInfo) error
	VisitString(string) error
}

func (s *SourceResponseSourcesItem) Accept(visitor SourceResponseSourcesItemVisitor) error {
	if s.typ == "SourceInfo" || s.SourceInfo != nil {
		return visitor.VisitSourceInfo(s.SourceInfo)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/Newscatcher/newscatcher-go/internal"
	time "time"
)

type SearchGetRequest struct {
	Q                      string   `json:"-" url:"q"`
	SearchIn               *string  `json:"-" url:"search_in,omitempty"`
	PredefinedSources      string   `json:"-" url:"predefined_sources"`
	Sources                string   `json:"-" url:"sources"`
	NotSources             string   `json:"-" url:"not_sources"`
	Lang                   string   `json:"-" url:"lang"`
	NotLang                string   `json:"-" url:"not_lang"`
	Countries              string   `json:"-" url:"countries"`
	NotCountries           string   `json:"-" url:"not_countries"`
	NotAuthorName          string   `json:"-" url:"not_author_name"`
	From                   *string  `json:"-" url:"from_,omitempty"`
	To                     *string  `json:"-" url:"to_,omitempty"`
	PublishedDatePrecision *string  `json:"-" url:"published_date_precision,omitempty"`
	ByParseDate            *string  `json:"-" url:"by_parse_date,omitempty"`
	SortBy                 *string  `json:"-" url:"sort_by,omitempty"`
	RankedOnly             *string  `json:"-" url:"ranked_only,omitempty"`
	FromRank               *string  `json:"-" url:"from_rank,omitempty"`
	ToRank                 *string  `json:"-" url:"to_rank,omitempty"`
	IsHeadline             *string  `json:"-" url:"is_headline,omitempty"`
	IsOpinion              *string  `json:"-" url:"is_opinion,omitempty"`
	IsPaidContent          *string  `json:"-" url:"is_paid_content,omitempty"`
	ParentUrl              string   `json:"-" url:"parent_url"`
	AllLinks               string   `json:"-" url:"all_links"`
	AllDomainLinks         string   `json:"-" url:"all_domain_links"`
	WordCountMin           *string  `json:"-" url:"word_count_min,omitempty"`
	WordCountMax           *string  `json:"-" url:"word_count_max,omitempty"`
	Page                   *string  `json:"-" url:"page,omitempty"`
	PageSize               *string  `json:"-" url:"page_size,omitempty"`
	ClusteringVariable     *string  `json:"-" url:"clustering_variable,omitempty"`
	ClusteringEnabled      *string  `json:"-" url:"clustering_enabled,omitempty"`
	ClusteringThreshold    *float64 `json:"-" url:"clustering_threshold,omitempty"`
	IncludeNlpData         *string  `json:"-" url:"include_nlp_data,omitempty"`
	HasNlp                 *bool    `json:"-" url:"has_nlp,omitempty"`
	Theme                  *string  `json:"-" url:"theme,omitempty"`
	NotTheme               *string  `json:"-" url:"not_theme,omitempty"`
	OrgEntityName          *string  `json:"-" url:"ORG_entity_name,omitempty"`
	PerEntityName          *string  `json:"-" url:"PER_entity_name,omitempty"`
	LocEntityName          *string  `json:"-" url:"LOC_entity_name,omitempty"`
	MiscEntityName         *string  `json:"-" url:"MISC_entity_name,omitempty"`
	TitleSentimentMin      *float64 `json:"-" url:"title_sentiment_min,omitempty"`
	TitleSentimentMax      *float64 `json:"-" url:"title_sentiment_max,omitempty"`
	ContentSentimentMin    *float64 `json:"-" url:"content_sentiment_min,omitempty"`
	ContentSentimentMax    *float64 `json:"-" url:"content_sentiment_max,omitempty"`
	IptcTags               string   `json:"-" url:"iptc_tags"`
	NotIptcTags            string   `json:"-" url:"not_iptc_tags"`
	SourceName             string   `json:"-" url:"source_name"`
	IabTags                string   `json:"-" url:"iab_tags"`
	NotIabTags             string   `json:"-" url:"not_iab_tags"`
	ExcludeDuplicates      *bool    `json:"-" url:"exclude_duplicates,omitempty"`
	AdditionalDomainInfo   *bool    `json:"-" url:"additional_domain_info,omitempty"`
	IsNewsDomain           *bool    `json:"-" url:"is_news_domain,omitempty"`
	NewsDomainType         string   `json:"-" url:"news_domain_type"`
	NewsType               string   `json:"-" url:"news_type"`
}

type SearchRequest struct {
	Q                      string                            `json:"q" url:"-"`
	SearchIn               *string                           `json:"search_in,omitempty" url:"-"`
	PredefinedSources      interface{}                       `json:"predefined_sources,omitempty" url:"-"`
	Sources                interface{}                       `json:"sources,omitempty" url:"-"`
	NotSources             interface{}                       `json:"not_sources,omitempty" url:"-"`
	Lang                   interface{}                       `json:"lang,omitempty" url:"-"`
	NotLang                interface{}                       `json:"not_lang,omitempty" url:"-"`
	Countries              interface{}                       `json:"countries,omitempty" url:"-"`
	NotCountries           interface{}                       `json:"not_countries,omitempty" url:"-"`
	NotAuthorName          interface{}                       `json:"not_author_name,omitempty" url:"-"`
	From                   *SearchRequestFrom                `json:"from_,omitempty" url:"-"`
	To                     *SearchRequestTo                  `json:"to_,omitempty" url:"-"`
	PublishedDatePrecision *string                           `json:"published_date_precision,omitempty" url:"-"`
	ByParseDate            *SearchRequestByParseDate         `json:"by_parse_date,omitempty" url:"-"`
	SortBy                 *string                           `json:"sort_by,omitempty" url:"-"`
	RankedOnly             *SearchRequestRankedOnly          `json:"ranked_only,omitempty" url:"-"`
	FromRank               *SearchRequestFromRank            `json:"from_rank,omitempty" url:"-"`
	ToRank                 *SearchRequestToRank              `json:"to_rank,omitempty" url:"-"`
	IsHeadline             *SearchRequestIsHeadline          `json:"is_headline,omitempty" url:"-"`
	IsOpinion              *SearchRequestIsOpinion           `json:"is_opinion,omitempty" url:"-"`
	IsPaidContent          *SearchRequestIsPaidContent       `json:"is_paid_content,omitempty" url:"-"`
	ParentUrl              interface{}                       `json:"parent_url,omitempty" url:"-"`
	AllLinks               interface{}                       `json:"all_links,omitempty" url:"-"`
	AllDomainLinks         interface{}                       `json:"all_domain_links,omitempty" url:"-"`
	WordCountMin           *SearchRequestWordCountMin        `json:"word_count_min,omitempty" url:"-"`
	WordCountMax           *SearchRequestWordCountMax        `json:"word_count_max,omitempty" url:"-"`
	Page                   *SearchRequestPage                `json:"page,omitempty" url:"-"`
	PageSize               *SearchRequestPageSize            `json:"page_size,omitempty" url:"-"`
	ClusteringVariable     *string                           `json:"clustering_variable,omitempty" url:"-"`
	ClusteringEnabled      *SearchRequestClusteringEnabled   `json:"clustering_enabled,omitempty" url:"-"`
	ClusteringThreshold    *SearchRequestClusteringThreshold `json:"clustering_threshold,omitempty" url:"-"`
	IncludeNlpData         *SearchRequestIncludeNlpData      `json:"include_nlp_data,omitempty" url:"-"`
	HasNlp                 *bool                             `json:"has_nlp,omitempty" url:"-"`
	Theme                  *string                           `json:"theme,omitempty" url:"-"`
	NotTheme               *string                           `json:"not_theme,omitempty" url:"-"`
	OrgEntityName          *string                           `json:"ORG_entity_name,omitempty" url:"-"`
	PerEntityName          *string                           `json:"PER_entity_name,omitempty" url:"-"`
	LocEntityName          *string                           `json:"LOC_entity_name,omitempty" url:"-"`
	MiscEntityName         *string                           `json:"MISC_entity_name,omitempty" url:"-"`
	TitleSentimentMin      *float64                          `json:"title_sentiment_min,omitempty" url:"-"`
	TitleSentimentMax      *float64                          `json:"title_sentiment_max,omitempty" url:"-"`
	ContentSentimentMin    *float64                          `json:"content_sentiment_min,omitempty" url:"-"`
	ContentSentimentMax    *float64                          `json:"content_sentiment_max,omitempty" url:"-"`
	IptcTags               interface{}                       `json:"iptc_tags,omitempty" url:"-"`
	NotIptcTags            interface{}                       `json:"not_iptc_tags,omitempty" url:"-"`
	SourceName             interface{}                       `json:"source_name,omitempty" url:"-"`
	IabTags                interface{}                       `json:"iab_tags,omitempty" url:"-"`
	NotIabTags             interface{}                       `json:"not_iab_tags,omitempty" url:"-"`
	ExcludeDuplicates      *bool                             `json:"exclude_duplicates,omitempty" url:"-"`
	AdditionalDomainInfo   *bool                             `json:"additional_domain_info,omitempty" url:"-"`
	IsNewsDomain           *bool                             `json:"is_news_domain,omitempty" url:"-"`
	NewsDomainType         interface{}                       `json:"news_domain_type,omitempty" url:"-"`
	NewsType               interface{}                       `json:"news_type,omitempty" url:"-"`
}

type SearchGetResponse struct {
	SearchResponse           *SearchResponse
	ClusteringSearchResponse *ClusteringSearchResponse

	typ string
}

func NewSearchGetResponseFromSearchResponse(value *SearchResponse) *SearchGetResponse {
	return &SearchGetResponse{typ: "SearchResponse", SearchResponse: value}
}

func NewSearchGetResponseFromClusteringSearchResponse(value *ClusteringSearchResponse) *SearchGetResponse {
	return &SearchGetResponse{typ: "ClusteringSearchResponse", ClusteringSearchResponse: value}
}

func (s *SearchGetResponse) GetSearchResponse() *SearchResponse {
	if s == nil {
		return nil
	}
	return s.SearchResponse
}

func (s *SearchGetResponse) GetClusteringSearchResponse() *ClusteringSearchResponse {
	if s == nil {
		return nil
	}
	return s.ClusteringSearchResponse
}

func (s *SearchGetResponse) UnmarshalJSON(data []byte) error {
	valueSearchResponse := new(SearchResponse)
	if err := json.Unmarshal(data, &valueSearchResponse); err == nil {
		s.typ = "SearchResponse"
		s.SearchResponse = valueSearchResponse
		return nil
	}
	valueClusteringSearchResponse := new(ClusteringSearchResponse)
	if err := json.Unmarshal(data, &valueClusteringSearchResponse); err == nil {
		s.typ = "ClusteringSearchResponse"
		s.ClusteringSearchResponse = valueClusteringSearchResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGetResponse) MarshalJSON() ([]byte, error) {
	if s.typ == "SearchResponse" || s.SearchResponse != nil {
		return json.Marshal(s.SearchResponse)
	}
	if s.typ == "ClusteringSearchResponse" || s.ClusteringSearchResponse != nil {
		return json.Marshal(s.ClusteringSearchResponse)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchGetResponseVisitor interface {
	VisitSearchResponse(*SearchResponse) error
	VisitClusteringSearchResponse(*ClusteringSearchResponse) error
}

func (s *SearchGetResponse) Accept(visitor SearchGetResponseVisitor) error {
	if s.typ == "SearchResponse" || s.SearchResponse != nil {
		return visitor.VisitSearchResponse(s.SearchResponse)
	}
	if s.typ == "ClusteringSearchResponse" || s.ClusteringSearchResponse != nil {
		return visitor.VisitClusteringSearchResponse(s.ClusteringSearchResponse)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchPostResponse struct {
	SearchResponse           *SearchResponse
	ClusteringSearchResponse *ClusteringSearchResponse

	typ string
}

func NewSearchPostResponseFromSearchResponse(value *SearchResponse) *SearchPostResponse {
	return &SearchPostResponse{typ: "SearchResponse", SearchResponse: value}
}

func NewSearchPostResponseFromClusteringSearchResponse(value *ClusteringSearchResponse) *SearchPostResponse {
	return &SearchPostResponse{typ: "ClusteringSearchResponse", ClusteringSearchResponse: value}
}

func (s *SearchPostResponse) GetSearchResponse() *SearchResponse {
	if s == nil {
		return nil
	}
	return s.SearchResponse
}

func (s *SearchPostResponse) GetClusteringSearchResponse() *ClusteringSearchResponse {
	if s == nil {
		return nil
	}
	return s.ClusteringSearchResponse
}

func (s *SearchPostResponse) UnmarshalJSON(data []byte) error {
	valueSearchResponse := new(SearchResponse)
	if err := json.Unmarshal(data, &valueSearchResponse); err == nil {
		s.typ = "SearchResponse"
		s.SearchResponse = valueSearchResponse
		return nil
	}
	valueClusteringSearchResponse := new(ClusteringSearchResponse)
	if err := json.Unmarshal(data, &valueClusteringSearchResponse); err == nil {
		s.typ = "ClusteringSearchResponse"
		s.ClusteringSearchResponse = valueClusteringSearchResponse
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchPostResponse) MarshalJSON() ([]byte, error) {
	if s.typ == "SearchResponse" || s.SearchResponse != nil {
		return json.Marshal(s.SearchResponse)
	}
	if s.typ == "ClusteringSearchResponse" || s.ClusteringSearchResponse != nil {
		return json.Marshal(s.ClusteringSearchResponse)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchPostResponseVisitor interface {
	VisitSearchResponse(*SearchResponse) error
	VisitClusteringSearchResponse(*ClusteringSearchResponse) error
}

func (s *SearchPostResponse) Accept(visitor SearchPostResponseVisitor) error {
	if s.typ == "SearchResponse" || s.SearchResponse != nil {
		return visitor.VisitSearchResponse(s.SearchResponse)
	}
	if s.typ == "ClusteringSearchResponse" || s.ClusteringSearchResponse != nil {
		return visitor.VisitClusteringSearchResponse(s.ClusteringSearchResponse)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestByParseDate struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestByParseDateFromString(value string) *SearchRequestByParseDate {
	return &SearchRequestByParseDate{typ: "String", String: value}
}

func NewSearchRequestByParseDateFromBoolean(value bool) *SearchRequestByParseDate {
	return &SearchRequestByParseDate{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestByParseDate) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestByParseDate) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestByParseDate) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestByParseDate) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestByParseDateVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestByParseDate) Accept(visitor SearchRequestByParseDateVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestClusteringEnabled struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestClusteringEnabledFromString(value string) *SearchRequestClusteringEnabled {
	return &SearchRequestClusteringEnabled{typ: "String", String: value}
}

func NewSearchRequestClusteringEnabledFromBoolean(value bool) *SearchRequestClusteringEnabled {
	return &SearchRequestClusteringEnabled{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestClusteringEnabled) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestClusteringEnabled) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestClusteringEnabled) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestClusteringEnabled) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestClusteringEnabledVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestClusteringEnabled) Accept(visitor SearchRequestClusteringEnabledVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestClusteringThreshold struct {
	Double float64
	String string

	typ string
}

func NewSearchRequestClusteringThresholdFromDouble(value float64) *SearchRequestClusteringThreshold {
	return &SearchRequestClusteringThreshold{typ: "Double", Double: value}
}

func NewSearchRequestClusteringThresholdFromString(value string) *SearchRequestClusteringThreshold {
	return &SearchRequestClusteringThreshold{typ: "String", String: value}
}

func (s *SearchRequestClusteringThreshold) GetDouble() float64 {
	if s == nil {
		return 0
	}
	return s.Double
}

func (s *SearchRequestClusteringThreshold) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestClusteringThreshold) UnmarshalJSON(data []byte) error {
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		s.typ = "Double"
		s.Double = valueDouble
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestClusteringThreshold) MarshalJSON() ([]byte, error) {
	if s.typ == "Double" || s.Double != 0 {
		return json.Marshal(s.Double)
	}
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestClusteringThresholdVisitor interface {
	VisitDouble(float64) error
	VisitString(string) error
}

func (s *SearchRequestClusteringThreshold) Accept(visitor SearchRequestClusteringThresholdVisitor) error {
	if s.typ == "Double" || s.Double != 0 {
		return visitor.VisitDouble(s.Double)
	}
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestFrom struct {
	String   string
	DateTime time.Time

	typ string
}

func NewSearchRequestFromFromString(value string) *SearchRequestFrom {
	return &SearchRequestFrom{typ: "String", String: value}
}

func NewSearchRequestFromFromDateTime(value time.Time) *SearchRequestFrom {
	return &SearchRequestFrom{typ: "DateTime", DateTime: value}
}

func (s *SearchRequestFrom) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestFrom) GetDateTime() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.DateTime
}

func (s *SearchRequestFrom) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueDateTime *internal.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		s.typ = "DateTime"
		s.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestFrom) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return json.Marshal(internal.NewDateTime(s.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestFromVisitor interface {
	VisitString(string) error
	VisitDateTime(time.Time) error
}

func (s *SearchRequestFrom) Accept(visitor SearchRequestFromVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return visitor.VisitDateTime(s.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestFromRank struct {
	String  string
	Integer int

	typ string
}

func NewSearchRequestFromRankFromString(value string) *SearchRequestFromRank {
	return &SearchRequestFromRank{typ: "String", String: value}
}

func NewSearchRequestFromRankFromInteger(value int) *SearchRequestFromRank {
	return &SearchRequestFromRank{typ: "Integer", Integer: value}
}

func (s *SearchRequestFromRank) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestFromRank) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *SearchRequestFromRank) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestFromRank) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestFromRankVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (s *SearchRequestFromRank) Accept(visitor SearchRequestFromRankVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIncludeNlpData struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestIncludeNlpDataFromString(value string) *SearchRequestIncludeNlpData {
	return &SearchRequestIncludeNlpData{typ: "String", String: value}
}

func NewSearchRequestIncludeNlpDataFromBoolean(value bool) *SearchRequestIncludeNlpData {
	return &SearchRequestIncludeNlpData{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestIncludeNlpData) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestIncludeNlpData) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestIncludeNlpData) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestIncludeNlpData) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIncludeNlpDataVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestIncludeNlpData) Accept(visitor SearchRequestIncludeNlpDataVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIsHeadline struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestIsHeadlineFromString(value string) *SearchRequestIsHeadline {
	return &SearchRequestIsHeadline{typ: "String", String: value}
}

func NewSearchRequestIsHeadlineFromBoolean(value bool) *SearchRequestIsHeadline {
	return &SearchRequestIsHeadline{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestIsHeadline) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestIsHeadline) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestIsHeadline) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestIsHeadline) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIsHeadlineVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestIsHeadline) Accept(visitor SearchRequestIsHeadlineVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIsOpinion struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestIsOpinionFromString(value string) *SearchRequestIsOpinion {
	return &SearchRequestIsOpinion{typ: "String", String: value}
}

func NewSearchRequestIsOpinionFromBoolean(value bool) *SearchRequestIsOpinion {
	return &SearchRequestIsOpinion{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestIsOpinion) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestIsOpinion) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestIsOpinion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestIsOpinion) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIsOpinionVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestIsOpinion) Accept(visitor SearchRequestIsOpinionVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIsPaidContent struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestIsPaidContentFromString(value string) *SearchRequestIsPaidContent {
	return &SearchRequestIsPaidContent{typ: "String", String: value}
}

func NewSearchRequestIsPaidContentFromBoolean(value bool) *SearchRequestIsPaidContent {
	return &SearchRequestIsPaidContent{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestIsPaidContent) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestIsPaidContent) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestIsPaidContent) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestIsPaidContent) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestIsPaidContentVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestIsPaidContent) Accept(visitor SearchRequestIsPaidContentVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestPage struct {
	String  string
	Integer int

	typ string
}

func NewSearchRequestPageFromString(value string) *SearchRequestPage {
	return &SearchRequestPage{typ: "String", String: value}
}

func NewSearchRequestPageFromInteger(value int) *SearchRequestPage {
	return &SearchRequestPage{typ: "Integer", Integer: value}
}

func (s *SearchRequestPage) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestPage) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *SearchRequestPage) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestPage) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestPageVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (s *SearchRequestPage) Accept(visitor SearchRequestPageVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestPageSize struct {
	String  string
	Integer int

	typ string
}

func NewSearchRequestPageSizeFromString(value string) *SearchRequestPageSize {
	return &SearchRequestPageSize{typ: "String", String: value}
}

func NewSearchRequestPageSizeFromInteger(value int) *SearchRequestPageSize {
	return &SearchRequestPageSize{typ: "Integer", Integer: value}
}

func (s *SearchRequestPageSize) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestPageSize) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *SearchRequestPageSize) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestPageSize) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestPageSizeVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (s *SearchRequestPageSize) Accept(visitor SearchRequestPageSizeVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestRankedOnly struct {
	String  string
	Boolean bool

	typ string
}

func NewSearchRequestRankedOnlyFromString(value string) *SearchRequestRankedOnly {
	return &SearchRequestRankedOnly{typ: "String", String: value}
}

func NewSearchRequestRankedOnlyFromBoolean(value bool) *SearchRequestRankedOnly {
	return &SearchRequestRankedOnly{typ: "Boolean", Boolean: value}
}

func (s *SearchRequestRankedOnly) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestRankedOnly) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SearchRequestRankedOnly) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestRankedOnly) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestRankedOnlyVisitor interface {
	VisitString(string) error
	VisitBoolean(bool) error
}

func (s *SearchRequestRankedOnly) Accept(visitor SearchRequestRankedOnlyVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestTo struct {
	String   string
	DateTime time.Time

	typ string
}

func NewSearchRequestToFromString(value string) *SearchRequestTo {
	return &SearchRequestTo{typ: "String", String: value}
}

func NewSearchRequestToFromDateTime(value time.Time) *SearchRequestTo {
	return &SearchRequestTo{typ: "DateTime", DateTime: value}
}

func (s *SearchRequestTo) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestTo) GetDateTime() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.DateTime
}

func (s *SearchRequestTo) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueDateTime *internal.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		s.typ = "DateTime"
		s.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestTo) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return json.Marshal(internal.NewDateTime(s.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestToVisitor interface {
	VisitString(string) error
	VisitDateTime(time.Time) error
}

func (s *SearchRequestTo) Accept(visitor SearchRequestToVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return visitor.VisitDateTime(s.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestToRank struct {
	String  string
	Integer int

	typ string
}

func NewSearchRequestToRankFromString(value string) *SearchRequestToRank {
	return &SearchRequestToRank{typ: "String", String: value}
}

func NewSearchRequestToRankFromInteger(value int) *SearchRequestToRank {
	return &SearchRequestToRank{typ: "Integer", Integer: value}
}

func (s *SearchRequestToRank) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestToRank) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *SearchRequestToRank) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestToRank) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestToRankVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (s *SearchRequestToRank) Accept(visitor SearchRequestToRankVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestWordCountMax struct {
	String  string
	Integer int

	typ string
}

func NewSearchRequestWordCountMaxFromString(value string) *SearchRequestWordCountMax {
	return &SearchRequestWordCountMax{typ: "String", String: value}
}

func NewSearchRequestWordCountMaxFromInteger(value int) *SearchRequestWordCountMax {
	return &SearchRequestWordCountMax{typ: "Integer", Integer: value}
}

func (s *SearchRequestWordCountMax) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestWordCountMax) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *SearchRequestWordCountMax) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestWordCountMax) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestWordCountMaxVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (s *SearchRequestWordCountMax) Accept(visitor SearchRequestWordCountMaxVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestWordCountMin struct {
	String  string
	Integer int

	typ string
}

func NewSearchRequestWordCountMinFromString(value string) *SearchRequestWordCountMin {
	return &SearchRequestWordCountMin{typ: "String", String: value}
}

func NewSearchRequestWordCountMinFromInteger(value int) *SearchRequestWordCountMin {
	return &SearchRequestWordCountMin{typ: "Integer", Integer: value}
}

func (s *SearchRequestWordCountMin) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchRequestWordCountMin) GetInteger() int {
	if s == nil {
		return 0
	}
	return s.Integer
}

func (s *SearchRequestWordCountMin) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		s.typ = "Integer"
		s.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchRequestWordCountMin) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return json.Marshal(s.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchRequestWordCountMinVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (s *SearchRequestWordCountMin) Accept(visitor SearchRequestWordCountMinVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Integer" || s.Integer != 0 {
		return visitor.VisitInteger(s.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

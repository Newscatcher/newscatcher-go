// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type SearchGetRequest struct {
	// The keyword(s) to search for in articles. Query syntax supports logical operators (`AND`, `OR`, `NOT`) and wildcards:
	//
	//   - For an exact match, use double quotes. For example, `"technology news"`.
	//   - Use `*` to search for any keyword.
	//   - Use `+` to include and `-` to exclude specific words or phrases.
	//     For example, `+Apple`, `-Google`.
	//   - Use `AND`, `OR`, and `NOT` to refine search results.
	//     For example, `technology AND (Apple OR Microsoft) NOT Google`.
	//
	// For more details, see [Advanced querying](/docs/v3/documentation/guides-and-concepts/advanced-querying).
	Q                        string                    `json:"-" url:"q"`
	SearchIn                 *SearchIn                 `json:"-" url:"search_in,omitempty"`
	IncludeTranslationFields *IncludeTranslationFields `json:"-" url:"include_translation_fields,omitempty"`
	// Predefined top news sources per country.
	//
	// Format: start with the word `top`, followed by the number of desired sources, and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). Multiple countries with the number of top sources can be specified as a comma-separated string.
	//
	// Examples:
	// - `"top 100 US"`
	// - `"top 33 AT"`
	// - `"top 50 US, top 20 GB"`
	// - `"top 33 AT, top 50 IT"`
	PredefinedSources *string `json:"-" url:"predefined_sources,omitempty"`
	// Word or phrase to search within the source names. To specify multiple values, use a comma-separated string.
	//
	// Example: `"sport, tech"`
	//
	// **Note**: The search doesn't require an exact match and returns sources containing the specified terms in their names. You can use any word or phrase, like `"sport"` or `"new york times"`. For example, `"sport"` returns sources such as `"Motorsport"`, `"Dot Esport"`, and `"Tuttosport"`.
	SourceName *string `json:"-" url:"source_name,omitempty"`
	// One or more news sources to narrow down the search. The format must be a domain URL. Subdomains, such as `finance.yahoo.com`, are also acceptable.To specify multiple sources, use a comma-separated string.
	//
	// Examples:
	// - `"nytimes.com"`
	// - `"theguardian.com, finance.yahoo.com"`
	Sources *string `json:"-" url:"sources,omitempty"`
	// The news sources to exclude from the search. To exclude multiple sources, use a comma-separated string.
	//
	// Example: `"cnn.com, wsj.com"`
	NotSources *string `json:"-" url:"not_sources,omitempty"`
	// The language(s) of the search. The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code. To select multiple languages, use a comma-separated string.
	//
	// Example: `"en, es"`
	//
	// To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
	Lang *string `json:"-" url:"lang,omitempty"`
	// The language(s) to exclude from the search. The accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code. To exclude multiple languages, use a comma-separated string.
	//
	// Example: `"fr, de"`
	//
	// To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
	NotLang *string `json:"-" url:"not_lang,omitempty"`
	// The countries where the news publisher is located. The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code. To select multiple countries, use a comma-separated string.
	//
	// Example: `"US, CA"`
	//
	// To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
	Countries *string `json:"-" url:"countries,omitempty"`
	// The publisher location countries to exclude from the search. The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code. To exclude multiple countries, use a comma-separated string.
	//
	// Example:`"US, CA"`
	//
	// To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
	NotCountries *string `json:"-" url:"not_countries,omitempty"`
	// The list of author names to exclude from your search. To exclude articles by specific authors, use a comma-separated string.
	//
	// Example: `"John Doe, Jane Doe"`
	NotAuthorName *string `json:"-" url:"not_author_name,omitempty"`
	// The starting point in time to search from. Accepts date-time strings in ISO 8601 format and plain text. The default time zone is UTC.
	//
	// Formats with examples:
	// - YYYY-mm-ddTHH:MM:SS: `2024-07-01T00:00:00`
	// - YYYY-MM-dd: `2024-07-01`
	// - YYYY/mm/dd HH:MM:SS: `2024/07/01 00:00:00`
	// - YYYY/mm/dd: `2024/07/01`
	// - English phrases: `7 day ago`, `today`
	//
	// **Note**: By default, applied to the publication date of the article. To use the article's parse date instead, set the `by_parse_date` parameter to `true`.
	From *time.Time `json:"-" url:"from_,omitempty"`
	// The ending point in time to search up to. Accepts date-time strings in ISO 8601 format and plain text. The default time zone is UTC.
	//
	// Formats with examples:
	// - YYYY-mm-ddTHH:MM:SS: `2024-07-01T00:00:00`
	// - YYYY-MM-dd: `2024-07-01`
	// - YYYY/mm/dd HH:MM:SS: `2024/07/01 00:00:00`
	// - YYYY/mm/dd: `2024/07/01`
	// - English phrases: `1 day ago`, `now`
	//
	// **Note**: By default, applied to the publication date of the article. To use the article's parse date instead, set the `by_parse_date` parameter to `true`.
	To *time.Time `json:"-" url:"to_,omitempty"`
	// The precision of the published date. There are three types:
	// - `full`: The day and time of an article is correctly identified with the appropriate timezone.
	// - `timezone unknown`: The day and time of an article is correctly identified without timezone.
	// - `date`: Only the day is identified without an exact time.
	PublishedDatePrecision *SearchGetRequestPublishedDatePrecision `json:"-" url:"published_date_precision,omitempty"`
	// If true, the `from_` and `to_` parameters use article parse dates instead of published dates. Additionally, the `parse_date` variable is added to the output for each article object.
	ByParseDate *bool `json:"-" url:"by_parse_date,omitempty"`
	// The sorting order of the results. Possible values are:
	// - `relevancy`: The most relevant results first.
	// - `date`: The most recently published results first.
	// - `rank`: The results from the highest-ranked sources first.
	SortBy *SearchGetRequestSortBy `json:"-" url:"sort_by,omitempty"`
	// If true, limits the search to sources ranked in the top 1 million online websites. If false, includes unranked sources which are assigned a rank of 999999.
	RankedOnly *bool `json:"-" url:"ranked_only,omitempty"`
	// The lowest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.
	FromRank *int `json:"-" url:"from_rank,omitempty"`
	// The highest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.
	ToRank *int `json:"-" url:"to_rank,omitempty"`
	// If true, only returns articles that were posted on the home page of a given news domain.
	IsHeadline *bool `json:"-" url:"is_headline,omitempty"`
	// If true, returns only opinion pieces. If false, excludes opinion-based articles and returns news only.
	IsOpinion *bool `json:"-" url:"is_opinion,omitempty"`
	// If false, returns only articles that have publicly available complete content. Some publishers partially block content, so this setting ensures that only full articles are retrieved.
	IsPaidContent *bool `json:"-" url:"is_paid_content,omitempty"`
	// The categorical URL(s) to filter your search. To filter your search by multiple categorical URLs, use a comma-separated string.
	//
	// Example: `"wsj.com/politics, wsj.com/tech"`
	ParentUrl *string `json:"-" url:"parent_url,omitempty"`
	// The complete URL(s) mentioned in the article. For multiple URLs, use a comma-separated string.
	//
	// Example: `"https://aiindex.stanford.edu/report, https://www.stateof.ai"`
	//
	// For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
	AllLinks *string `json:"-" url:"all_links,omitempty"`
	// The domain(s) mentioned in the article. For multiple domains, use a comma-separated string.
	//
	// Example: `"who.int, nih.gov"`
	//
	// For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
	AllDomainLinks *string `json:"-" url:"all_domain_links,omitempty"`
	// If true, includes additional domain information in the response for each article:
	// - `is_news_domain`: Boolean indicating if the source is a news domain.
	// - `news_domain_type`: Type of news domain (e.g., `"Original Content"`).
	// - `news_type`: Category of news (e.g., `"News and Blogs"`).
	AdditionalDomainInfo *bool `json:"-" url:"additional_domain_info,omitempty"`
	// If true, filters results to include only news domains.
	IsNewsDomain *bool `json:"-" url:"is_news_domain,omitempty"`
	// Filters results based on the news domain type. Possible values are:
	// - `Original Content`: Sources that produce their own content.
	// - `Aggregator`: Sources that collect content from various other sources.
	// - `Press Releases`: Sources primarily publishing press releases.
	// - `Republisher`: Sources that republish content from other sources.
	// - `Other`: Sources that don't fit into main categories.
	NewsDomainType *SearchGetRequestNewsDomainType `json:"-" url:"news_domain_type,omitempty"`
	// Filters results based on the news type. Multiple types can be specified using a comma-separated string.
	//
	// Example: `"General News Outlets,Tech News and Updates"`
	//
	// For a complete list of available news types, see [Enumerated parameters > News type](/docs/v3/api-reference/overview/enumerated-parameters#news-type-news-type).
	NewsType *string `json:"-" url:"news_type,omitempty"`
	// The minimum number of words an article must contain. To be used for avoiding articles with small content.
	WordCountMin *int `json:"-" url:"word_count_min,omitempty"`
	// The maximum number of words an article can contain. To be used for avoiding articles with large content.
	WordCountMax *int `json:"-" url:"word_count_max,omitempty"`
	// The page number to scroll through the results. Use for pagination, as a single API response can return up to 1,000 articles.
	//
	// For details, see [How to paginate large datasets](https://www.newscatcherapi.com/docs/v3/documentation/how-to/paginate-large-datasets).
	Page *int `json:"-" url:"page,omitempty"`
	// The number of articles to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// Determines whether to group similar articles into clusters. If true, the API returns clustered results.
	//
	// To learn more, see [Clustering news articles](/docs/v3/documentation/guides-and-concepts/clustering-news-articles).
	ClusteringEnabled *bool `json:"-" url:"clustering_enabled,omitempty"`
	// Specifies which part of the article to use for determining similarity when clustering.
	//
	// Possible values are:
	// - `content`: Uses the full article content (default).
	// - `title`: Uses only the article title.
	// - `summary`: Uses the article summary.
	//
	// To learn more, see [Clustering news articles](/docs/v3/documentation/guides-and-concepts/clustering-news-articles).
	ClusteringVariable *SearchGetRequestClusteringVariable `json:"-" url:"clustering_variable,omitempty"`
	// Sets the similarity threshold for grouping articles into clusters. A lower value creates more inclusive clusters, while a higher value requires greater similarity between articles.
	//
	// Examples:
	// - `0.3`: Results in larger, more diverse clusters.
	// - `0.6`: Balances cluster size and article similarity (default).
	// - `0.9`: Creates smaller, tightly related clusters.
	//
	// To learn more, see [Clustering news articles](/docs/v3/documentation/guides-and-concepts/clustering-news-articles).
	ClusteringThreshold *float64        `json:"-" url:"clustering_threshold,omitempty"`
	IncludeNlpData      *IncludeNlpData `json:"-" url:"include_nlp_data,omitempty"`
	HasNlp              *HasNlp         `json:"-" url:"has_nlp,omitempty"`
	// Filters articles based on their general topic, as determined by NLP analysis. To select multiple themes, use a comma-separated string.
	//
	// Example: `"Finance, Tech"`
	//
	// **Note**: The `theme` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	//
	// Available options: `Business`, `Economics`, `Entertainment`, `Finance`, `Health`, `Politics`, `Science`, `Sports`, `Tech`, `Crime`, `Financial Crime`, `Lifestyle`, `Automotive`, `Travel`, `Weather`, `General`.
	Theme *string `json:"-" url:"theme,omitempty"`
	// Inverse of the `theme` parameter. Excludes articles based on their general topic, as determined by NLP analysis. To exclude multiple themes, use a comma-separated string.
	//
	// Example: `"Crime, Tech"`
	//
	// **Note**: The `not_theme` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	NotTheme *string `json:"-" url:"not_theme,omitempty"`
	// Filters articles that mention specific organization names, as identified by NLP analysis. To specify multiple organizations, use a comma-separated string. To search named entities in translations, combine with the translation options of the `search_in` parameter (e.g., `title_content_translated`).
	//
	// Example: `"Apple, Microsoft"`
	//
	// **Note**: The `ORG_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	OrgEntityName *string `json:"-" url:"ORG_entity_name,omitempty"`
	// Filters articles that mention specific person names, as identified by NLP analysis. To specify multiple names, use a comma-separated string. To search named entities in translations, combine with the translation options of the `search_in` parameter (e.g., `title_content_translated`).
	//
	// Example: `"Elon Musk, Jeff Bezos"`
	//
	// **Note**: The `PER_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	PerEntityName *string `json:"-" url:"PER_entity_name,omitempty"`
	// Filters articles that mention specific location names, as identified by NLP analysis. To specify multiple locations, use a comma-separated string. To search named entities in translations, combine with the translation options of the `search_in` parameter (e.g., `title_content_translated`).
	//
	// Example: `"California, New York"`
	//
	// **Note**: The `LOC_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	LocEntityName *string `json:"-" url:"LOC_entity_name,omitempty"`
	// Filters articles that mention other named entities not falling under person, organization, or location categories. Includes events, nationalities, products, works of art, and more. To specify multiple entities, use a comma-separated string. To search named entities in translations, combine with the translation options of the `search_in` parameter (e.g., `title_content_translated`).
	//
	// Example: `"Bitcoin, Blockchain"`
	//
	// **Note**: The `MISC_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	MiscEntityName *string `json:"-" url:"MISC_entity_name,omitempty"`
	// Filters articles based on the minimum sentiment score of their titles.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `title_sentiment_min` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	TitleSentimentMin *float64 `json:"-" url:"title_sentiment_min,omitempty"`
	// Filters articles based on the maximum sentiment score of their titles.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `title_sentiment_max` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	TitleSentimentMax *float64 `json:"-" url:"title_sentiment_max,omitempty"`
	// Filters articles based on the minimum sentiment score of their content.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `content_sentiment_min` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	ContentSentimentMin *float64 `json:"-" url:"content_sentiment_min,omitempty"`
	// Filters articles based on the maximum sentiment score of their content.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `content_sentiment_max` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	ContentSentimentMax *float64 `json:"-" url:"content_sentiment_max,omitempty"`
	// Filters articles based on International Press Telecommunications Council (IPTC) media topic tags. To specify multiple IPTC tags, use a comma-separated string of tag IDs.
	//
	// Example: `"20000199, 20000209"`
	//
	// **Note**: The `iptc_tags` parameter is only available in the `v3_nlp_iptc_tags` subscription plan.
	//
	// To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
	IptcTags *string `json:"-" url:"iptc_tags,omitempty"`
	// Inverse of the `iptc_tags` parameter. Excludes articles based on International Press Telecommunications Council (IPTC) media topic tags. To specify multiple IPTC tags to exclude, use a comma-separated string of tag IDs.
	//
	// Example: `"20000205, 20000209"`
	//
	// **Note**: The `not_iptc_tags` parameter is only available in the `v3_nlp_iptc_tags` subscription plan.
	//
	// To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
	NotIptcTags *string `json:"-" url:"not_iptc_tags,omitempty"`
	// Filters articles based on Interactive Advertising Bureau (IAB) content categories. These tags provide a standardized taxonomy for digital advertising content categorization. To specify multiple IAB categories, use a comma-separated string.
	//
	// Example: `"Business, Events"`
	//
	// **Note**: The `iab_tags` parameter is only available in the `v3_nlp_iptc_tags` subscription plan.
	//
	// To learn more, see the [IAB Content taxonomy](https://iabtechlab.com/standards/content-taxonomy/).
	IabTags *string `json:"-" url:"iab_tags,omitempty"`
	// Inverse of the `iab_tags` parameter. Excludes articles based on Interactive Advertising Bureau (IAB) content categories. These tags provide a standardized taxonomy for digital advertising content categorization. To specify multiple IAB categories to exclude, use a comma-separated string.
	//
	// Example: `"Agriculture, Metals"`
	//
	// **Note**: The `not_iab_tags` parameter is only available in the `v3_nlp_iptc_tags` subscription plan.
	//
	// To learn more, see the [IAB Content taxonomy](https://iabtechlab.com/standards/content-taxonomy/).
	NotIabTags *string `json:"-" url:"not_iab_tags,omitempty"`
	// Filters articles based on provided taxonomy that is tailored to your specific needs and is accessible only with your API key. To specify tags, use the following pattern:
	//
	// - `custom_tags.taxonomy=Tag1,Tag2,Tag3`, where `taxonomy` is the taxonomy name and `Tag1,Tag2,Tag3` is a comma-separated list of tags.
	//
	// Example: `custom_tags.industry="Manufacturing, Supply Chain, Logistics"`
	//
	// To learn more, see the [Custom tags](/docs/v3/documentation/guides-and-concepts/custom-tags).
	CustomTags *string `json:"-" url:"custom_tags,omitempty"`
	// If true, excludes duplicate and highly similar articles from the search results. If false, returns all relevant articles, including duplicates.
	//
	// To learn more, see [Articles deduplication](/docs/v3/documentation/guides-and-concepts/articles-deduplication).
	ExcludeDuplicates *bool `json:"-" url:"exclude_duplicates,omitempty"`
	// If true, returns only articles/sources that comply with the publisher's robots.txt rules. If false, returns only articles/sources that do not comply with robots.txt rules. If omitted, returns all articles/sources regardless of compliance status.
	RobotsCompliant *bool `json:"-" url:"robots_compliant,omitempty"`
}

type SearchPostRequest struct {
	Q                        Q                         `json:"q" url:"-"`
	SearchIn                 *SearchIn                 `json:"search_in,omitempty" url:"-"`
	IncludeTranslationFields *IncludeTranslationFields `json:"include_translation_fields,omitempty" url:"-"`
	PredefinedSources        *PredefinedSources        `json:"predefined_sources,omitempty" url:"-"`
	SourceName               *SourceName               `json:"source_name,omitempty" url:"-"`
	Sources                  *Sources                  `json:"sources,omitempty" url:"-"`
	NotSources               *NotSources               `json:"not_sources,omitempty" url:"-"`
	Lang                     *Lang                     `json:"lang,omitempty" url:"-"`
	NotLang                  *NotLang                  `json:"not_lang,omitempty" url:"-"`
	Countries                *Countries                `json:"countries,omitempty" url:"-"`
	NotCountries             *NotCountries             `json:"not_countries,omitempty" url:"-"`
	NotAuthorName            *NotAuthorName            `json:"not_author_name,omitempty" url:"-"`
	From                     *From                     `json:"from_,omitempty" url:"-"`
	To                       *To                       `json:"to_,omitempty" url:"-"`
	PublishedDatePrecision   *PublishedDatePrecision   `json:"published_date_precision,omitempty" url:"-"`
	ByParseDate              *ByParseDate              `json:"by_parse_date,omitempty" url:"-"`
	SortBy                   *SortBy                   `json:"sort_by,omitempty" url:"-"`
	RankedOnly               *RankedOnly               `json:"ranked_only,omitempty" url:"-"`
	FromRank                 *FromRank                 `json:"from_rank,omitempty" url:"-"`
	ToRank                   *ToRank                   `json:"to_rank,omitempty" url:"-"`
	IsHeadline               *IsHeadline               `json:"is_headline,omitempty" url:"-"`
	IsOpinion                *IsOpinion                `json:"is_opinion,omitempty" url:"-"`
	IsPaidContent            *IsPaidContent            `json:"is_paid_content,omitempty" url:"-"`
	ParentUrl                *ParentUrl                `json:"parent_url,omitempty" url:"-"`
	AllLinks                 *AllLinks                 `json:"all_links,omitempty" url:"-"`
	AllDomainLinks           *AllDomainLinks           `json:"all_domain_links,omitempty" url:"-"`
	AdditionalDomainInfo     *AdditionalDomainInfo     `json:"additional_domain_info,omitempty" url:"-"`
	IsNewsDomain             *IsNewsDomain             `json:"is_news_domain,omitempty" url:"-"`
	NewsDomainType           *NewsDomainType           `json:"news_domain_type,omitempty" url:"-"`
	NewsType                 *NewsType                 `json:"news_type,omitempty" url:"-"`
	WordCountMin             *WordCountMin             `json:"word_count_min,omitempty" url:"-"`
	WordCountMax             *WordCountMax             `json:"word_count_max,omitempty" url:"-"`
	Page                     *Page                     `json:"page,omitempty" url:"-"`
	PageSize                 *PageSize                 `json:"page_size,omitempty" url:"-"`
	ClusteringEnabled        *ClusteringEnabled        `json:"clustering_enabled,omitempty" url:"-"`
	ClusteringVariable       *ClusteringVariable       `json:"clustering_variable,omitempty" url:"-"`
	ClusteringThreshold      *ClusteringThreshold      `json:"clustering_threshold,omitempty" url:"-"`
	IncludeNlpData           *IncludeNlpData           `json:"include_nlp_data,omitempty" url:"-"`
	HasNlp                   *HasNlp                   `json:"has_nlp,omitempty" url:"-"`
	Theme                    *Theme                    `json:"theme,omitempty" url:"-"`
	NotTheme                 *NotTheme                 `json:"not_theme,omitempty" url:"-"`
	OrgEntityName            *OrgEntityName            `json:"ORG_entity_name,omitempty" url:"-"`
	PerEntityName            *PerEntityName            `json:"PER_entity_name,omitempty" url:"-"`
	LocEntityName            *LocEntityName            `json:"LOC_entity_name,omitempty" url:"-"`
	MiscEntityName           *MiscEntityName           `json:"MISC_entity_name,omitempty" url:"-"`
	TitleSentimentMin        *TitleSentimentMin        `json:"title_sentiment_min,omitempty" url:"-"`
	TitleSentimentMax        *TitleSentimentMax        `json:"title_sentiment_max,omitempty" url:"-"`
	ContentSentimentMin      *ContentSentimentMin      `json:"content_sentiment_min,omitempty" url:"-"`
	ContentSentimentMax      *ContentSentimentMax      `json:"content_sentiment_max,omitempty" url:"-"`
	IptcTags                 *IptcTags                 `json:"iptc_tags,omitempty" url:"-"`
	NotIptcTags              *NotIptcTags              `json:"not_iptc_tags,omitempty" url:"-"`
	IabTags                  *IabTags                  `json:"iab_tags,omitempty" url:"-"`
	NotIabTags               *NotIabTags               `json:"not_iab_tags,omitempty" url:"-"`
	CustomTags               *CustomTags               `json:"custom_tags,omitempty" url:"-"`
	ExcludeDuplicates        *ExcludeDuplicates        `json:"exclude_duplicates,omitempty" url:"-"`
	RobotsCompliant          *RobotsCompliant          `json:"robots_compliant,omitempty" url:"-"`
}

// If true, includes additional domain information in the response for each article:
// - `is_news_domain`: Boolean indicating if the source is a news domain.
// - `news_domain_type`: Type of news domain (e.g., `"Original Content"`).
// - `news_type`: Category of news (e.g., `"News and Blogs"`).
type AdditionalDomainInfo = bool

// If true, excludes duplicate and highly similar articles from the search results. If false, returns all relevant articles, including duplicates.
//
// To learn more, see [Articles deduplication](/docs/v3/documentation/guides-and-concepts/articles-deduplication).
type ExcludeDuplicates = bool

type SearchGetRequestClusteringVariable string

const (
	SearchGetRequestClusteringVariableContent SearchGetRequestClusteringVariable = "content"
	SearchGetRequestClusteringVariableTitle   SearchGetRequestClusteringVariable = "title"
	SearchGetRequestClusteringVariableSummary SearchGetRequestClusteringVariable = "summary"
)

func NewSearchGetRequestClusteringVariableFromString(s string) (SearchGetRequestClusteringVariable, error) {
	switch s {
	case "content":
		return SearchGetRequestClusteringVariableContent, nil
	case "title":
		return SearchGetRequestClusteringVariableTitle, nil
	case "summary":
		return SearchGetRequestClusteringVariableSummary, nil
	}
	var t SearchGetRequestClusteringVariable
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchGetRequestClusteringVariable) Ptr() *SearchGetRequestClusteringVariable {
	return &s
}

type SearchGetRequestNewsDomainType string

const (
	SearchGetRequestNewsDomainTypeOriginalContent SearchGetRequestNewsDomainType = "Original Content"
	SearchGetRequestNewsDomainTypeAggregator      SearchGetRequestNewsDomainType = "Aggregator"
	SearchGetRequestNewsDomainTypePressReleases   SearchGetRequestNewsDomainType = "Press Releases"
	SearchGetRequestNewsDomainTypeRepublisher     SearchGetRequestNewsDomainType = "Republisher"
	SearchGetRequestNewsDomainTypeOther           SearchGetRequestNewsDomainType = "Other"
)

func NewSearchGetRequestNewsDomainTypeFromString(s string) (SearchGetRequestNewsDomainType, error) {
	switch s {
	case "Original Content":
		return SearchGetRequestNewsDomainTypeOriginalContent, nil
	case "Aggregator":
		return SearchGetRequestNewsDomainTypeAggregator, nil
	case "Press Releases":
		return SearchGetRequestNewsDomainTypePressReleases, nil
	case "Republisher":
		return SearchGetRequestNewsDomainTypeRepublisher, nil
	case "Other":
		return SearchGetRequestNewsDomainTypeOther, nil
	}
	var t SearchGetRequestNewsDomainType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchGetRequestNewsDomainType) Ptr() *SearchGetRequestNewsDomainType {
	return &s
}

type SearchGetRequestPublishedDatePrecision string

const (
	SearchGetRequestPublishedDatePrecisionFull            SearchGetRequestPublishedDatePrecision = "full"
	SearchGetRequestPublishedDatePrecisionTimezoneUnknown SearchGetRequestPublishedDatePrecision = "timezone unknown"
	SearchGetRequestPublishedDatePrecisionDate            SearchGetRequestPublishedDatePrecision = "date"
)

func NewSearchGetRequestPublishedDatePrecisionFromString(s string) (SearchGetRequestPublishedDatePrecision, error) {
	switch s {
	case "full":
		return SearchGetRequestPublishedDatePrecisionFull, nil
	case "timezone unknown":
		return SearchGetRequestPublishedDatePrecisionTimezoneUnknown, nil
	case "date":
		return SearchGetRequestPublishedDatePrecisionDate, nil
	}
	var t SearchGetRequestPublishedDatePrecision
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchGetRequestPublishedDatePrecision) Ptr() *SearchGetRequestPublishedDatePrecision {
	return &s
}

type SearchGetRequestSortBy string

const (
	SearchGetRequestSortByRelevancy SearchGetRequestSortBy = "relevancy"
	SearchGetRequestSortByDate      SearchGetRequestSortBy = "date"
	SearchGetRequestSortByRank      SearchGetRequestSortBy = "rank"
)

func NewSearchGetRequestSortByFromString(s string) (SearchGetRequestSortBy, error) {
	switch s {
	case "relevancy":
		return SearchGetRequestSortByRelevancy, nil
	case "date":
		return SearchGetRequestSortByDate, nil
	case "rank":
		return SearchGetRequestSortByRank, nil
	}
	var t SearchGetRequestSortBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchGetRequestSortBy) Ptr() *SearchGetRequestSortBy {
	return &s
}

type SearchGetResponse struct {
	SearchResponseDto          *SearchResponseDto
	ClusteredSearchResponseDto *ClusteredSearchResponseDto

	typ string
}

func NewSearchGetResponseFromSearchResponseDto(value *SearchResponseDto) *SearchGetResponse {
	return &SearchGetResponse{typ: "SearchResponseDto", SearchResponseDto: value}
}

func NewSearchGetResponseFromClusteredSearchResponseDto(value *ClusteredSearchResponseDto) *SearchGetResponse {
	return &SearchGetResponse{typ: "ClusteredSearchResponseDto", ClusteredSearchResponseDto: value}
}

func (s *SearchGetResponse) GetSearchResponseDto() *SearchResponseDto {
	if s == nil {
		return nil
	}
	return s.SearchResponseDto
}

func (s *SearchGetResponse) GetClusteredSearchResponseDto() *ClusteredSearchResponseDto {
	if s == nil {
		return nil
	}
	return s.ClusteredSearchResponseDto
}

func (s *SearchGetResponse) UnmarshalJSON(data []byte) error {
	valueSearchResponseDto := new(SearchResponseDto)
	if err := json.Unmarshal(data, &valueSearchResponseDto); err == nil {
		s.typ = "SearchResponseDto"
		s.SearchResponseDto = valueSearchResponseDto
		return nil
	}
	valueClusteredSearchResponseDto := new(ClusteredSearchResponseDto)
	if err := json.Unmarshal(data, &valueClusteredSearchResponseDto); err == nil {
		s.typ = "ClusteredSearchResponseDto"
		s.ClusteredSearchResponseDto = valueClusteredSearchResponseDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchGetResponse) MarshalJSON() ([]byte, error) {
	if s.typ == "SearchResponseDto" || s.SearchResponseDto != nil {
		return json.Marshal(s.SearchResponseDto)
	}
	if s.typ == "ClusteredSearchResponseDto" || s.ClusteredSearchResponseDto != nil {
		return json.Marshal(s.ClusteredSearchResponseDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchGetResponseVisitor interface {
	VisitSearchResponseDto(*SearchResponseDto) error
	VisitClusteredSearchResponseDto(*ClusteredSearchResponseDto) error
}

func (s *SearchGetResponse) Accept(visitor SearchGetResponseVisitor) error {
	if s.typ == "SearchResponseDto" || s.SearchResponseDto != nil {
		return visitor.VisitSearchResponseDto(s.SearchResponseDto)
	}
	if s.typ == "ClusteredSearchResponseDto" || s.ClusteredSearchResponseDto != nil {
		return visitor.VisitClusteredSearchResponseDto(s.ClusteredSearchResponseDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchPostResponse struct {
	SearchResponseDto          *SearchResponseDto
	ClusteredSearchResponseDto *ClusteredSearchResponseDto

	typ string
}

func NewSearchPostResponseFromSearchResponseDto(value *SearchResponseDto) *SearchPostResponse {
	return &SearchPostResponse{typ: "SearchResponseDto", SearchResponseDto: value}
}

func NewSearchPostResponseFromClusteredSearchResponseDto(value *ClusteredSearchResponseDto) *SearchPostResponse {
	return &SearchPostResponse{typ: "ClusteredSearchResponseDto", ClusteredSearchResponseDto: value}
}

func (s *SearchPostResponse) GetSearchResponseDto() *SearchResponseDto {
	if s == nil {
		return nil
	}
	return s.SearchResponseDto
}

func (s *SearchPostResponse) GetClusteredSearchResponseDto() *ClusteredSearchResponseDto {
	if s == nil {
		return nil
	}
	return s.ClusteredSearchResponseDto
}

func (s *SearchPostResponse) UnmarshalJSON(data []byte) error {
	valueSearchResponseDto := new(SearchResponseDto)
	if err := json.Unmarshal(data, &valueSearchResponseDto); err == nil {
		s.typ = "SearchResponseDto"
		s.SearchResponseDto = valueSearchResponseDto
		return nil
	}
	valueClusteredSearchResponseDto := new(ClusteredSearchResponseDto)
	if err := json.Unmarshal(data, &valueClusteredSearchResponseDto); err == nil {
		s.typ = "ClusteredSearchResponseDto"
		s.ClusteredSearchResponseDto = valueClusteredSearchResponseDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchPostResponse) MarshalJSON() ([]byte, error) {
	if s.typ == "SearchResponseDto" || s.SearchResponseDto != nil {
		return json.Marshal(s.SearchResponseDto)
	}
	if s.typ == "ClusteredSearchResponseDto" || s.ClusteredSearchResponseDto != nil {
		return json.Marshal(s.ClusteredSearchResponseDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchPostResponseVisitor interface {
	VisitSearchResponseDto(*SearchResponseDto) error
	VisitClusteredSearchResponseDto(*ClusteredSearchResponseDto) error
}

func (s *SearchPostResponse) Accept(visitor SearchPostResponseVisitor) error {
	if s.typ == "SearchResponseDto" || s.SearchResponseDto != nil {
		return visitor.VisitSearchResponseDto(s.SearchResponseDto)
	}
	if s.typ == "ClusteredSearchResponseDto" || s.ClusteredSearchResponseDto != nil {
		return visitor.VisitClusteredSearchResponseDto(s.ClusteredSearchResponseDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

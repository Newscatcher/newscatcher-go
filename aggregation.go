// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/Newscatcher/newscatcher-go/internal"
	time "time"
)

type AggregationGetRequest struct {
	// The keyword(s) to search for in articles. Query syntax supports logical operators (`AND`, `OR`, `NOT`) and wildcards:
	//
	//   - For an exact match, use double quotes. For example, `"technology news"`.
	//   - Use `*` to search for any keyword.
	//   - Use `+` to include and `-` to exclude specific words or phrases.
	//     For example, `+Apple`, `-Google`.
	//   - Use `AND`, `OR`, and `NOT` to refine search results.
	//     For example, `technology AND (Apple OR Microsoft) NOT Google`.
	//
	// For more details, see [Advanced querying](/docs/v3/documentation/guides-and-concepts/advanced-querying).
	Q string `json:"-" url:"q"`
	// The article fields to search in. To search in multiple fields, use a comma-separated string.
	//
	// Example: `"title, summary"`
	//
	// **Note**: The `summary` option is available if NLP is enabled in your plan.
	//
	// Available options: `title`, `summary`, `content`.
	SearchIn *string `json:"-" url:"search_in,omitempty"`
	// Predefined top news sources per country.
	//
	// Format: start with the word `top`, followed by the number of desired sources, and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). Multiple countries with the number of top sources can be specified as a comma-separated string.
	//
	// Examples:
	// - `"top 100 US"`
	// - `"top 33 AT"`
	// - `"top 50 US, top 20 GB"`
	// - `"top 33 AT, top 50 IT"`
	PredefinedSources *string `json:"-" url:"predefined_sources,omitempty"`
	// One or more news sources to narrow down the search. The format must be a domain URL. Subdomains, such as `finance.yahoo.com`, are also acceptable.To specify multiple sources, use a comma-separated string.
	//
	// Examples:
	// - `"nytimes.com"`
	// - `"theguardian.com, finance.yahoo.com"`
	Sources *string `json:"-" url:"sources,omitempty"`
	// The news sources to exclude from the search. To exclude multiple sources, use a comma-separated string.
	//
	// Example: `"cnn.com, wsj.com"`
	NotSources *string `json:"-" url:"not_sources,omitempty"`
	// The language(s) of the search. The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code. To select multiple languages, use a comma-separated string.
	//
	// Example: `"en, es"`
	//
	// To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
	Lang *string `json:"-" url:"lang,omitempty"`
	// The language(s) to exclude from the search. The accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code. To exclude multiple languages, use a comma-separated string.
	//
	// Example: `"fr, de"`
	//
	// To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
	NotLang *string `json:"-" url:"not_lang,omitempty"`
	// The countries where the news publisher is located. The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code. To select multiple countries, use a comma-separated string.
	//
	// Example: `"US, CA"`
	//
	// To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
	Countries *string `json:"-" url:"countries,omitempty"`
	// The publisher location countries to exclude from the search. The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code. To exclude multiple countries, use a comma-separated string.
	//
	// Example:`"US, CA"`
	//
	// To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
	NotCountries *string `json:"-" url:"not_countries,omitempty"`
	// The list of author names to exclude from your search. To exclude articles by specific authors, use a comma-separated string.
	//
	// Example: `"John Doe, Jane Doe"`
	NotAuthorName *string `json:"-" url:"not_author_name,omitempty"`
	// The starting point in time to search from. Accepts date-time strings in ISO 8601 format and plain text. The default time zone is UTC.
	//
	// Formats with examples:
	// - YYYY-mm-ddTHH:MM:SS: `2024-07-01T00:00:00`
	// - YYYY-MM-dd: `2024-07-01`
	// - YYYY/mm/dd HH:MM:SS: `2024/07/01 00:00:00`
	// - YYYY/mm/dd: `2024/07/01`
	// - English phrases: `1 day ago`, `today`
	//
	// **Note**: By default, applied to the publication date of the article. To use the article's parse date instead, set the `by_parse_date` parameter to `true`.
	From *time.Time `json:"-" url:"from_,omitempty"`
	// The ending point in time to search up to. Accepts date-time strings in ISO 8601 format and plain text. The default time zone is UTC.
	//
	// Formats with examples:
	// - YYYY-mm-ddTHH:MM:SS: `2024-07-01T00:00:00`
	// - YYYY-MM-dd: `2024-07-01`
	// - YYYY/mm/dd HH:MM:SS: `2024/07/01 00:00:00`
	// - YYYY/mm/dd: `2024/07/01`
	// - English phrases: `1 day ago`, `today`
	//
	// **Note**: By default, applied to the publication date of the article. To use the article's parse date instead, set the `by_parse_date` parameter to `true`.
	To *time.Time `json:"-" url:"to_,omitempty"`
	// The precision of the published date. There are three types:
	// - `full`: The day and time of an article is correctly identified with the appropriate timezone.
	// - `timezone unknown`: The day and time of an article is correctly identified without timezone.
	// - `date`: Only the day is identified without an exact time.
	PublishedDatePrecision *AggregationGetRequestPublishedDatePrecision `json:"-" url:"published_date_precision,omitempty"`
	// If true, the `from_` and `to_` parameters use article parse dates instead of published dates. Additionally, the `parse_date` variable is added to the output for each article object.
	ByParseDate *bool `json:"-" url:"by_parse_date,omitempty"`
	// The sorting order of the results. Possible values are:
	// - `relevancy`: The most relevant results first.
	// - `date`: The most recently published results first.
	// - `rank`: The results from the highest-ranked sources first.
	SortBy *AggregationGetRequestSortBy `json:"-" url:"sort_by,omitempty"`
	// If true, limits the search to sources ranked in the top 1 million online websites. If false, includes unranked sources which are assigned a rank of 999999.
	RankedOnly *bool `json:"-" url:"ranked_only,omitempty"`
	// The lowest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.
	FromRank *int `json:"-" url:"from_rank,omitempty"`
	// The highest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.
	ToRank *int `json:"-" url:"to_rank,omitempty"`
	// If true, only returns articles that were posted on the home page of a given news domain.
	IsHeadline *bool `json:"-" url:"is_headline,omitempty"`
	// If true, returns only opinion pieces. If false, excludes opinion-based articles and returns news only.
	IsOpinion *bool `json:"-" url:"is_opinion,omitempty"`
	// If false, returns only articles that have publicly available complete content. Some publishers partially block content, so this setting ensures that only full articles are retrieved.
	IsPaidContent *bool `json:"-" url:"is_paid_content,omitempty"`
	// The categorical URL(s) to filter your search. To filter your search by multiple categorical URLs, use a comma-separated string.
	//
	// Example: `"wsj.com/politics, wsj.com/tech"`
	ParentUrl *string `json:"-" url:"parent_url,omitempty"`
	// The complete URL(s) mentioned in the article. For multiple URLs, use a comma-separated string.
	//
	// Example: `"https://aiindex.stanford.edu/report, https://www.stateof.ai"`
	//
	// For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
	AllLinks *string `json:"-" url:"all_links,omitempty"`
	// The domain(s) mentioned in the article. For multiple domains, use a comma-separated string.
	//
	// Example: `"who.int, nih.gov"`
	//
	// For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
	AllDomainLinks *string `json:"-" url:"all_domain_links,omitempty"`
	// The minimum number of words an article must contain. To be used for avoiding articles with small content.
	WordCountMin *int `json:"-" url:"word_count_min,omitempty"`
	// The maximum number of words an article can contain. To be used for avoiding articles with large content.
	WordCountMax *int `json:"-" url:"word_count_max,omitempty"`
	// The page number to scroll through the results. Use for pagination, as a single API response can return up to 1,000 articles.
	//
	// For details, see [How to paginate large datasets](https://www.newscatcherapi.com/docs/v3/documentation/how-to/paginate-large-datasets).
	Page *int `json:"-" url:"page,omitempty"`
	// The number of articles to return per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// If true, includes an NLP layer with each article in the response. This layer provides enhanced information such as theme classification, article summary, sentiment analysis, tags, and named entity recognition.
	//
	// The NLP layer includes:
	// - Theme: General topic of the article.
	// - Summary: A concise overview of the article content.
	// - Sentiment: Separate scores for title and content (range: -1 to 1).
	// - Named entities: Identified persons (PER), organizations (ORG), locations (LOC), and miscellaneous entities (MISC).
	// - IPTC tags: Standardized news category tags.
	// - IAB tags: Content categories for digital advertising.
	//
	// **Note**: The `include_nlp_data` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	IncludeNlpData *bool `json:"-" url:"include_nlp_data,omitempty"`
	// If true, filters the results to include only articles with an NLP layer. This allows you to focus on articles that have been processed with advanced NLP techniques.
	//
	// **Note**: The `has_nlp` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	HasNlp *bool `json:"-" url:"has_nlp,omitempty"`
	// Filters articles based on their general topic, as determined by NLP analysis. To select multiple themes, use a comma-separated string.
	//
	// Example: `"Finance, Tech"`
	//
	// **Note**: The `theme` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	//
	// Available options: `Business`, `Economics`, `Entertainment`, `Finance`, `Health`, `Politics`, `Science`, `Sports`, `Tech`, `Crime`, `Financial Crime`, `Lifestyle`, `Automotive`, `Travel`, `Weather`, `General`.
	Theme *string `json:"-" url:"theme,omitempty"`
	// Inverse of the `theme` parameter. Excludes articles based on their general topic, as determined by NLP analysis. To exclude multiple themes, use a comma-separated string.
	//
	// Example: `"Crime, Tech"`
	//
	// **Note**: The `not_theme` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	NotTheme *string `json:"-" url:"not_theme,omitempty"`
	// Filters articles that mention specific organization names, as identified by NLP analysis. To specify multiple organizations, use a comma-separated string.
	//
	// Example: `"Apple, Microsoft"`
	//
	// **Note**: The `ORG_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	OrgEntityName *string `json:"-" url:"ORG_entity_name,omitempty"`
	// Filters articles that mention specific person names, as identified by NLP analysis. To specify multiple names, use a comma-separated string.
	//
	// Example: `"Elon Musk, Jeff Bezos"`
	//
	// **Note**: The `PER_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	PerEntityName *string `json:"-" url:"PER_entity_name,omitempty"`
	// Filters articles that mention specific location names, as identified by NLP analysis. To specify multiple locations, use a comma-separated string.
	//
	// Example: `"California, New York"`
	//
	// **Note**: The `LOC_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	LocEntityName *string `json:"-" url:"LOC_entity_name,omitempty"`
	// Filters articles that mention other named entities not falling under person, organization, or location categories. Includes events, nationalities, products, works of art, and more. To specify multiple entities, use a comma-separated string.
	//
	// Example: `"Bitcoin, Blockchain"`
	//
	// **Note**: The `MISC_entity_name` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [Search by entity](/docs/v3/documentation/how-to/search-by-entity).
	MiscEntityName *string `json:"-" url:"MISC_entity_name,omitempty"`
	// Filters articles based on the minimum sentiment score of their titles.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `title_sentiment_min` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	TitleSentimentMin *float64 `json:"-" url:"title_sentiment_min,omitempty"`
	// Filters articles based on the maximum sentiment score of their titles.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `title_sentiment_max` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	TitleSentimentMax *float64 `json:"-" url:"title_sentiment_max,omitempty"`
	// Filters articles based on the minimum sentiment score of their content.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `content_sentiment_min` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	ContentSentimentMin *float64 `json:"-" url:"content_sentiment_min,omitempty"`
	// Filters articles based on the maximum sentiment score of their content.
	//
	// Range is `-1.0` to `1.0`, where:
	// - Negative values indicate negative sentiment.
	// - Positive values indicate positive sentiment.
	// - Values close to 0 indicate neutral sentiment.
	//
	// **Note**: The `content_sentiment_max` parameter is only available if NLP is included in your subscription plan.
	//
	// To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
	ContentSentimentMax *float64 `json:"-" url:"content_sentiment_max,omitempty"`
	// Filters articles based on International Press Telecommunications Council (IPTC) media topic tags. To specify multiple IPTC tags, use a comma-separated string of tag IDs.
	//
	// Example: `"20000199, 20000209"`
	//
	// **Note**: The `iptc_tags` parameter is only available if tags are included in your subscription plan.
	//
	// To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
	IptcTags *string `json:"-" url:"iptc_tags,omitempty"`
	// Inverse of the `iptc_tags` parameter. Excludes articles based on International Press Telecommunications Council (IPTC) media topic tags. To specify multiple IPTC tags to exclude, use a comma-separated string of tag IDs.
	//
	// Example: `"20000205, 20000209"`
	//
	// **Note**: The `not_iptc_tags` parameter is only available if tags are included in your subscription plan.
	//
	// To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
	NotIptcTags *string `json:"-" url:"not_iptc_tags,omitempty"`
	// The aggregation interval for the results. Possible values are:
	// - `day`: Aggregates results by day.
	// - `hour`: Aggregates results by hour.
	AggregationBy *AggregationGetRequestAggregationBy `json:"-" url:"aggregation_by,omitempty"`
}

type AggregationPostRequest struct {
	Q                      Q                       `json:"q" url:"-"`
	SearchIn               *SearchIn               `json:"search_in,omitempty" url:"-"`
	PredefinedSources      *PredefinedSources      `json:"predefined_sources,omitempty" url:"-"`
	Sources                *Sources                `json:"sources,omitempty" url:"-"`
	NotSources             *NotSources             `json:"not_sources,omitempty" url:"-"`
	Lang                   *Lang                   `json:"lang,omitempty" url:"-"`
	NotLang                *NotLang                `json:"not_lang,omitempty" url:"-"`
	Countries              *Countries              `json:"countries,omitempty" url:"-"`
	NotCountries           *NotCountries           `json:"not_countries,omitempty" url:"-"`
	NotAuthorName          *NotAuthorName          `json:"not_author_name,omitempty" url:"-"`
	From                   *From                   `json:"from_,omitempty" url:"-"`
	To                     *To                     `json:"to_,omitempty" url:"-"`
	PublishedDatePrecision *PublishedDatePrecision `json:"published_date_precision,omitempty" url:"-"`
	ByParseDate            *ByParseDate            `json:"by_parse_date,omitempty" url:"-"`
	SortBy                 *SortBy                 `json:"sort_by,omitempty" url:"-"`
	RankedOnly             *RankedOnly             `json:"ranked_only,omitempty" url:"-"`
	FromRank               *FromRank               `json:"from_rank,omitempty" url:"-"`
	ToRank                 *ToRank                 `json:"to_rank,omitempty" url:"-"`
	IsHeadline             *IsHeadline             `json:"is_headline,omitempty" url:"-"`
	IsOpinion              *IsOpinion              `json:"is_opinion,omitempty" url:"-"`
	IsPaidContent          *IsPaidContent          `json:"is_paid_content,omitempty" url:"-"`
	ParentUrl              *ParentUrl              `json:"parent_url,omitempty" url:"-"`
	AllLinks               *AllLinks               `json:"all_links,omitempty" url:"-"`
	AllDomainLinks         *AllDomainLinks         `json:"all_domain_links,omitempty" url:"-"`
	WordCountMin           *WordCountMin           `json:"word_count_min,omitempty" url:"-"`
	WordCountMax           *WordCountMax           `json:"word_count_max,omitempty" url:"-"`
	Page                   *Page                   `json:"page,omitempty" url:"-"`
	PageSize               *PageSize               `json:"page_size,omitempty" url:"-"`
	IncludeNlpData         *IncludeNlpData         `json:"include_nlp_data,omitempty" url:"-"`
	HasNlp                 *HasNlp                 `json:"has_nlp,omitempty" url:"-"`
	Theme                  *Theme                  `json:"theme,omitempty" url:"-"`
	NotTheme               *NotTheme               `json:"not_theme,omitempty" url:"-"`
	OrgEntityName          *OrgEntityName          `json:"ORG_entity_name,omitempty" url:"-"`
	PerEntityName          *PerEntityName          `json:"PER_entity_name,omitempty" url:"-"`
	LocEntityName          *LocEntityName          `json:"LOC_entity_name,omitempty" url:"-"`
	MiscEntityName         *MiscEntityName         `json:"MISC_entity_name,omitempty" url:"-"`
	TitleSentimentMin      *TitleSentimentMin      `json:"title_sentiment_min,omitempty" url:"-"`
	TitleSentimentMax      *TitleSentimentMax      `json:"title_sentiment_max,omitempty" url:"-"`
	ContentSentimentMin    *ContentSentimentMin    `json:"content_sentiment_min,omitempty" url:"-"`
	ContentSentientMax     *ContentSentimentMax    `json:"content_sentient_max,omitempty" url:"-"`
	IptcTags               *IptcTags               `json:"iptc_tags,omitempty" url:"-"`
	NotIptcTags            *NotIptcTags            `json:"not_iptc_tags,omitempty" url:"-"`
	AggregationBy          *AggregationBy          `json:"aggregation_by,omitempty" url:"-"`
}

// The aggregation interval for the results. Possible values are:
// - `day`: Aggregates results by day.
// - `hour`: Aggregates results by hour.
type AggregationBy string

const (
	AggregationByDay  AggregationBy = "day"
	AggregationByHour AggregationBy = "hour"
)

func NewAggregationByFromString(s string) (AggregationBy, error) {
	switch s {
	case "day":
		return AggregationByDay, nil
	case "hour":
		return AggregationByHour, nil
	}
	var t AggregationBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregationBy) Ptr() *AggregationBy {
	return &a
}

// The response model for a successful `Aggregation count` request. Response field behavior:
// - Required fields are guaranteed to be present and non-null.
// - Optional fields may be `null`/`undefined` if the data couldn't be extracted
// during processing.
type AggregationCountResponseDto struct {
	// The status of the response.
	Status string `json:"status" url:"status"`
	// The total number of articles matching the search criteria.
	TotalHits int `json:"total_hits" url:"total_hits"`
	// The current page number of the results.
	Page int `json:"page" url:"page"`
	// The total number of pages available for the given search criteria.
	TotalPages int `json:"total_pages" url:"total_pages"`
	// The number of articles per page.
	PageSize int `json:"page_size" url:"page_size"`
	// The aggregation results. Can be either a dictionary or a list of dictionaries.
	Aggregations *Aggregations `json:"aggregations,omitempty" url:"aggregations,omitempty"`
	UserInput    *UserInputDto `json:"user_input,omitempty" url:"user_input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AggregationCountResponseDto) GetStatus() string {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *AggregationCountResponseDto) GetTotalHits() int {
	if a == nil {
		return 0
	}
	return a.TotalHits
}

func (a *AggregationCountResponseDto) GetPage() int {
	if a == nil {
		return 0
	}
	return a.Page
}

func (a *AggregationCountResponseDto) GetTotalPages() int {
	if a == nil {
		return 0
	}
	return a.TotalPages
}

func (a *AggregationCountResponseDto) GetPageSize() int {
	if a == nil {
		return 0
	}
	return a.PageSize
}

func (a *AggregationCountResponseDto) GetAggregations() *Aggregations {
	if a == nil {
		return nil
	}
	return a.Aggregations
}

func (a *AggregationCountResponseDto) GetUserInput() *UserInputDto {
	if a == nil {
		return nil
	}
	return a.UserInput
}

func (a *AggregationCountResponseDto) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregationCountResponseDto) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregationCountResponseDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregationCountResponseDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregationCountResponseDto) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A single item in the aggregations array containing a collection of time-based article counts.
type AggregationItem struct {
	// Array of time frames and their corresponding article counts
	AggregationCount []*TimeFrameCount `json:"aggregation_count,omitempty" url:"aggregation_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AggregationItem) GetAggregationCount() []*TimeFrameCount {
	if a == nil {
		return nil
	}
	return a.AggregationCount
}

func (a *AggregationItem) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AggregationItem) UnmarshalJSON(data []byte) error {
	type unmarshaler AggregationItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AggregationItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AggregationItem) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The aggregation results. Can be either a dictionary or a list of dictionaries.
type Aggregations struct {
	AggregationItem     *AggregationItem
	AggregationItemList []*AggregationItem

	typ string
}

func NewAggregationsFromAggregationItem(value *AggregationItem) *Aggregations {
	return &Aggregations{typ: "AggregationItem", AggregationItem: value}
}

func NewAggregationsFromAggregationItemList(value []*AggregationItem) *Aggregations {
	return &Aggregations{typ: "AggregationItemList", AggregationItemList: value}
}

func (a *Aggregations) GetAggregationItem() *AggregationItem {
	if a == nil {
		return nil
	}
	return a.AggregationItem
}

func (a *Aggregations) GetAggregationItemList() []*AggregationItem {
	if a == nil {
		return nil
	}
	return a.AggregationItemList
}

func (a *Aggregations) UnmarshalJSON(data []byte) error {
	valueAggregationItem := new(AggregationItem)
	if err := json.Unmarshal(data, &valueAggregationItem); err == nil {
		a.typ = "AggregationItem"
		a.AggregationItem = valueAggregationItem
		return nil
	}
	var valueAggregationItemList []*AggregationItem
	if err := json.Unmarshal(data, &valueAggregationItemList); err == nil {
		a.typ = "AggregationItemList"
		a.AggregationItemList = valueAggregationItemList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a Aggregations) MarshalJSON() ([]byte, error) {
	if a.typ == "AggregationItem" || a.AggregationItem != nil {
		return json.Marshal(a.AggregationItem)
	}
	if a.typ == "AggregationItemList" || a.AggregationItemList != nil {
		return json.Marshal(a.AggregationItemList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregationsVisitor interface {
	VisitAggregationItem(*AggregationItem) error
	VisitAggregationItemList([]*AggregationItem) error
}

func (a *Aggregations) Accept(visitor AggregationsVisitor) error {
	if a.typ == "AggregationItem" || a.AggregationItem != nil {
		return visitor.VisitAggregationItem(a.AggregationItem)
	}
	if a.typ == "AggregationItemList" || a.AggregationItemList != nil {
		return visitor.VisitAggregationItemList(a.AggregationItemList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// The response model for a failed `Aggregation count` request.
type FailedAggregationCountResponseDto struct {
	// The status of the response.
	Status string `json:"status" url:"status"`
	// The total number of articles matching the search criteria.
	TotalHits int `json:"total_hits" url:"total_hits"`
	// The current page number of the results.
	Page int `json:"page" url:"page"`
	// The total number of pages available for the given search criteria.
	TotalPages int `json:"total_pages" url:"total_pages"`
	// The number of articles per page.
	PageSize  int           `json:"page_size" url:"page_size"`
	UserInput *UserInputDto `json:"user_input,omitempty" url:"user_input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FailedAggregationCountResponseDto) GetStatus() string {
	if f == nil {
		return ""
	}
	return f.Status
}

func (f *FailedAggregationCountResponseDto) GetTotalHits() int {
	if f == nil {
		return 0
	}
	return f.TotalHits
}

func (f *FailedAggregationCountResponseDto) GetPage() int {
	if f == nil {
		return 0
	}
	return f.Page
}

func (f *FailedAggregationCountResponseDto) GetTotalPages() int {
	if f == nil {
		return 0
	}
	return f.TotalPages
}

func (f *FailedAggregationCountResponseDto) GetPageSize() int {
	if f == nil {
		return 0
	}
	return f.PageSize
}

func (f *FailedAggregationCountResponseDto) GetUserInput() *UserInputDto {
	if f == nil {
		return nil
	}
	return f.UserInput
}

func (f *FailedAggregationCountResponseDto) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FailedAggregationCountResponseDto) UnmarshalJSON(data []byte) error {
	type unmarshaler FailedAggregationCountResponseDto
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FailedAggregationCountResponseDto(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FailedAggregationCountResponseDto) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Represents the article count for a specific time frame.
type TimeFrameCount struct {
	// The timestamp for the aggregation period in format "YYYY-MM-DD HH:mm:ss"
	TimeFrame time.Time `json:"time_frame" url:"time_frame"`
	// The number of articles published during this time frame
	ArticleCount int `json:"article_count" url:"article_count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeFrameCount) GetTimeFrame() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.TimeFrame
}

func (t *TimeFrameCount) GetArticleCount() int {
	if t == nil {
		return 0
	}
	return t.ArticleCount
}

func (t *TimeFrameCount) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeFrameCount) UnmarshalJSON(data []byte) error {
	type embed TimeFrameCount
	var unmarshaler = struct {
		embed
		TimeFrame *internal.DateTime `json:"time_frame"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeFrameCount(unmarshaler.embed)
	t.TimeFrame = unmarshaler.TimeFrame.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeFrameCount) MarshalJSON() ([]byte, error) {
	type embed TimeFrameCount
	var marshaler = struct {
		embed
		TimeFrame *internal.DateTime `json:"time_frame"`
	}{
		embed:     embed(*t),
		TimeFrame: internal.NewDateTime(t.TimeFrame),
	}
	return json.Marshal(marshaler)
}

func (t *TimeFrameCount) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type AggregationGetRequestAggregationBy string

const (
	AggregationGetRequestAggregationByDay  AggregationGetRequestAggregationBy = "day"
	AggregationGetRequestAggregationByHour AggregationGetRequestAggregationBy = "hour"
)

func NewAggregationGetRequestAggregationByFromString(s string) (AggregationGetRequestAggregationBy, error) {
	switch s {
	case "day":
		return AggregationGetRequestAggregationByDay, nil
	case "hour":
		return AggregationGetRequestAggregationByHour, nil
	}
	var t AggregationGetRequestAggregationBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregationGetRequestAggregationBy) Ptr() *AggregationGetRequestAggregationBy {
	return &a
}

type AggregationGetRequestPublishedDatePrecision string

const (
	AggregationGetRequestPublishedDatePrecisionFull            AggregationGetRequestPublishedDatePrecision = "full"
	AggregationGetRequestPublishedDatePrecisionTimezoneUnknown AggregationGetRequestPublishedDatePrecision = "timezone unknown"
	AggregationGetRequestPublishedDatePrecisionDate            AggregationGetRequestPublishedDatePrecision = "date"
)

func NewAggregationGetRequestPublishedDatePrecisionFromString(s string) (AggregationGetRequestPublishedDatePrecision, error) {
	switch s {
	case "full":
		return AggregationGetRequestPublishedDatePrecisionFull, nil
	case "timezone unknown":
		return AggregationGetRequestPublishedDatePrecisionTimezoneUnknown, nil
	case "date":
		return AggregationGetRequestPublishedDatePrecisionDate, nil
	}
	var t AggregationGetRequestPublishedDatePrecision
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregationGetRequestPublishedDatePrecision) Ptr() *AggregationGetRequestPublishedDatePrecision {
	return &a
}

type AggregationGetRequestSortBy string

const (
	AggregationGetRequestSortByRelevancy AggregationGetRequestSortBy = "relevancy"
	AggregationGetRequestSortByDate      AggregationGetRequestSortBy = "date"
	AggregationGetRequestSortByRank      AggregationGetRequestSortBy = "rank"
)

func NewAggregationGetRequestSortByFromString(s string) (AggregationGetRequestSortBy, error) {
	switch s {
	case "relevancy":
		return AggregationGetRequestSortByRelevancy, nil
	case "date":
		return AggregationGetRequestSortByDate, nil
	case "rank":
		return AggregationGetRequestSortByRank, nil
	}
	var t AggregationGetRequestSortBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AggregationGetRequestSortBy) Ptr() *AggregationGetRequestSortBy {
	return &a
}

type AggregationGetResponse struct {
	AggregationCountResponseDto       *AggregationCountResponseDto
	FailedAggregationCountResponseDto *FailedAggregationCountResponseDto

	typ string
}

func NewAggregationGetResponseFromAggregationCountResponseDto(value *AggregationCountResponseDto) *AggregationGetResponse {
	return &AggregationGetResponse{typ: "AggregationCountResponseDto", AggregationCountResponseDto: value}
}

func NewAggregationGetResponseFromFailedAggregationCountResponseDto(value *FailedAggregationCountResponseDto) *AggregationGetResponse {
	return &AggregationGetResponse{typ: "FailedAggregationCountResponseDto", FailedAggregationCountResponseDto: value}
}

func (a *AggregationGetResponse) GetAggregationCountResponseDto() *AggregationCountResponseDto {
	if a == nil {
		return nil
	}
	return a.AggregationCountResponseDto
}

func (a *AggregationGetResponse) GetFailedAggregationCountResponseDto() *FailedAggregationCountResponseDto {
	if a == nil {
		return nil
	}
	return a.FailedAggregationCountResponseDto
}

func (a *AggregationGetResponse) UnmarshalJSON(data []byte) error {
	valueAggregationCountResponseDto := new(AggregationCountResponseDto)
	if err := json.Unmarshal(data, &valueAggregationCountResponseDto); err == nil {
		a.typ = "AggregationCountResponseDto"
		a.AggregationCountResponseDto = valueAggregationCountResponseDto
		return nil
	}
	valueFailedAggregationCountResponseDto := new(FailedAggregationCountResponseDto)
	if err := json.Unmarshal(data, &valueFailedAggregationCountResponseDto); err == nil {
		a.typ = "FailedAggregationCountResponseDto"
		a.FailedAggregationCountResponseDto = valueFailedAggregationCountResponseDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AggregationGetResponse) MarshalJSON() ([]byte, error) {
	if a.typ == "AggregationCountResponseDto" || a.AggregationCountResponseDto != nil {
		return json.Marshal(a.AggregationCountResponseDto)
	}
	if a.typ == "FailedAggregationCountResponseDto" || a.FailedAggregationCountResponseDto != nil {
		return json.Marshal(a.FailedAggregationCountResponseDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregationGetResponseVisitor interface {
	VisitAggregationCountResponseDto(*AggregationCountResponseDto) error
	VisitFailedAggregationCountResponseDto(*FailedAggregationCountResponseDto) error
}

func (a *AggregationGetResponse) Accept(visitor AggregationGetResponseVisitor) error {
	if a.typ == "AggregationCountResponseDto" || a.AggregationCountResponseDto != nil {
		return visitor.VisitAggregationCountResponseDto(a.AggregationCountResponseDto)
	}
	if a.typ == "FailedAggregationCountResponseDto" || a.FailedAggregationCountResponseDto != nil {
		return visitor.VisitFailedAggregationCountResponseDto(a.FailedAggregationCountResponseDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregationPostResponse struct {
	AggregationCountResponseDto       *AggregationCountResponseDto
	FailedAggregationCountResponseDto *FailedAggregationCountResponseDto

	typ string
}

func NewAggregationPostResponseFromAggregationCountResponseDto(value *AggregationCountResponseDto) *AggregationPostResponse {
	return &AggregationPostResponse{typ: "AggregationCountResponseDto", AggregationCountResponseDto: value}
}

func NewAggregationPostResponseFromFailedAggregationCountResponseDto(value *FailedAggregationCountResponseDto) *AggregationPostResponse {
	return &AggregationPostResponse{typ: "FailedAggregationCountResponseDto", FailedAggregationCountResponseDto: value}
}

func (a *AggregationPostResponse) GetAggregationCountResponseDto() *AggregationCountResponseDto {
	if a == nil {
		return nil
	}
	return a.AggregationCountResponseDto
}

func (a *AggregationPostResponse) GetFailedAggregationCountResponseDto() *FailedAggregationCountResponseDto {
	if a == nil {
		return nil
	}
	return a.FailedAggregationCountResponseDto
}

func (a *AggregationPostResponse) UnmarshalJSON(data []byte) error {
	valueAggregationCountResponseDto := new(AggregationCountResponseDto)
	if err := json.Unmarshal(data, &valueAggregationCountResponseDto); err == nil {
		a.typ = "AggregationCountResponseDto"
		a.AggregationCountResponseDto = valueAggregationCountResponseDto
		return nil
	}
	valueFailedAggregationCountResponseDto := new(FailedAggregationCountResponseDto)
	if err := json.Unmarshal(data, &valueFailedAggregationCountResponseDto); err == nil {
		a.typ = "FailedAggregationCountResponseDto"
		a.FailedAggregationCountResponseDto = valueFailedAggregationCountResponseDto
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AggregationPostResponse) MarshalJSON() ([]byte, error) {
	if a.typ == "AggregationCountResponseDto" || a.AggregationCountResponseDto != nil {
		return json.Marshal(a.AggregationCountResponseDto)
	}
	if a.typ == "FailedAggregationCountResponseDto" || a.FailedAggregationCountResponseDto != nil {
		return json.Marshal(a.FailedAggregationCountResponseDto)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AggregationPostResponseVisitor interface {
	VisitAggregationCountResponseDto(*AggregationCountResponseDto) error
	VisitFailedAggregationCountResponseDto(*FailedAggregationCountResponseDto) error
}

func (a *AggregationPostResponse) Accept(visitor AggregationPostResponseVisitor) error {
	if a.typ == "AggregationCountResponseDto" || a.AggregationCountResponseDto != nil {
		return visitor.VisitAggregationCountResponseDto(a.AggregationCountResponseDto)
	}
	if a.typ == "FailedAggregationCountResponseDto" || a.FailedAggregationCountResponseDto != nil {
		return visitor.VisitFailedAggregationCountResponseDto(a.FailedAggregationCountResponseDto)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

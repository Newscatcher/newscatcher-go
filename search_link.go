// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/Newscatcher/newscatcher-go/internal"
	time "time"
)

type SearchUrlRequest struct {
	Ids      interface{}           `json:"ids,omitempty" url:"-"`
	Links    interface{}           `json:"links,omitempty" url:"-"`
	From     *SearchUrlRequestFrom `json:"from_,omitempty" url:"-"`
	To       *SearchUrlRequestTo   `json:"to_,omitempty" url:"-"`
	Page     *int                  `json:"page,omitempty" url:"-"`
	PageSize *int                  `json:"page_size,omitempty" url:"-"`
}

type SearchUrlGetRequest struct {
	Ids      string  `json:"-" url:"ids"`
	Links    string  `json:"-" url:"links"`
	From     *string `json:"-" url:"from_,omitempty"`
	To       *string `json:"-" url:"to_,omitempty"`
	Page     *int    `json:"-" url:"page,omitempty"`
	PageSize *int    `json:"-" url:"page_size,omitempty"`
}

type SearchUrlRequestFrom struct {
	String   string
	DateTime time.Time

	typ string
}

func NewSearchUrlRequestFromFromString(value string) *SearchUrlRequestFrom {
	return &SearchUrlRequestFrom{typ: "String", String: value}
}

func NewSearchUrlRequestFromFromDateTime(value time.Time) *SearchUrlRequestFrom {
	return &SearchUrlRequestFrom{typ: "DateTime", DateTime: value}
}

func (s *SearchUrlRequestFrom) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchUrlRequestFrom) GetDateTime() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.DateTime
}

func (s *SearchUrlRequestFrom) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueDateTime *internal.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		s.typ = "DateTime"
		s.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchUrlRequestFrom) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return json.Marshal(internal.NewDateTime(s.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchUrlRequestFromVisitor interface {
	VisitString(string) error
	VisitDateTime(time.Time) error
}

func (s *SearchUrlRequestFrom) Accept(visitor SearchUrlRequestFromVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return visitor.VisitDateTime(s.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchUrlRequestTo struct {
	String   string
	DateTime time.Time

	typ string
}

func NewSearchUrlRequestToFromString(value string) *SearchUrlRequestTo {
	return &SearchUrlRequestTo{typ: "String", String: value}
}

func NewSearchUrlRequestToFromDateTime(value time.Time) *SearchUrlRequestTo {
	return &SearchUrlRequestTo{typ: "DateTime", DateTime: value}
}

func (s *SearchUrlRequestTo) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SearchUrlRequestTo) GetDateTime() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.DateTime
}

func (s *SearchUrlRequestTo) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueDateTime *internal.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		s.typ = "DateTime"
		s.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SearchUrlRequestTo) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return json.Marshal(internal.NewDateTime(s.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SearchUrlRequestToVisitor interface {
	VisitString(string) error
	VisitDateTime(time.Time) error
}

func (s *SearchUrlRequestTo) Accept(visitor SearchUrlRequestToVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "DateTime" || !s.DateTime.IsZero() {
		return visitor.VisitDateTime(s.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/Newscatcher/newscatcher-go/internal"
)

// ArticleResult DTO class.
type ArticleResult struct {
	Title                  string                                                       `json:"title" url:"title"`
	Author                 *string                                                      `json:"author,omitempty" url:"author,omitempty"`
	Authors                *Authors                                                     `json:"authors,omitempty" url:"authors,omitempty"`
	Journalists            *Journalists                                                 `json:"journalists,omitempty" url:"journalists,omitempty"`
	PublishedDate          *string                                                      `json:"published_date,omitempty" url:"published_date,omitempty"`
	PublishedDatePrecision *string                                                      `json:"published_date_precision,omitempty" url:"published_date_precision,omitempty"`
	UpdatedDate            *string                                                      `json:"updated_date,omitempty" url:"updated_date,omitempty"`
	UpdatedDatePrecision   *string                                                      `json:"updated_date_precision,omitempty" url:"updated_date_precision,omitempty"`
	ParseDate              *string                                                      `json:"parse_date,omitempty" url:"parse_date,omitempty"`
	Link                   string                                                       `json:"link" url:"link"`
	DomainUrl              string                                                       `json:"domain_url" url:"domain_url"`
	FullDomainUrl          string                                                       `json:"full_domain_url" url:"full_domain_url"`
	NameSource             *string                                                      `json:"name_source,omitempty" url:"name_source,omitempty"`
	IsHeadline             *string                                                      `json:"is_headline,omitempty" url:"is_headline,omitempty"`
	PaidContent            *bool                                                        `json:"paid_content,omitempty" url:"paid_content,omitempty"`
	ExtractionData         string                                                       `json:"extraction_data" url:"extraction_data"`
	Country                *string                                                      `json:"country,omitempty" url:"country,omitempty"`
	Rights                 *string                                                      `json:"rights,omitempty" url:"rights,omitempty"`
	Rank                   int                                                          `json:"rank" url:"rank"`
	Media                  *string                                                      `json:"media,omitempty" url:"media,omitempty"`
	Language               *string                                                      `json:"language,omitempty" url:"language,omitempty"`
	Description            *string                                                      `json:"description,omitempty" url:"description,omitempty"`
	Content                string                                                       `json:"content" url:"content"`
	TitleTranslatedEn      *string                                                      `json:"title_translated_en,omitempty" url:"title_translated_en,omitempty"`
	ContentTranslatedEn    *string                                                      `json:"content_translated_en,omitempty" url:"content_translated_en,omitempty"`
	WordCount              *int                                                         `json:"word_count,omitempty" url:"word_count,omitempty"`
	IsOpinion              *bool                                                        `json:"is_opinion,omitempty" url:"is_opinion,omitempty"`
	TwitterAccount         *string                                                      `json:"twitter_account,omitempty" url:"twitter_account,omitempty"`
	AllLinks               *DtoResponsesMoreLikeThisResponseArticleResultAllLinks       `json:"all_links,omitempty" url:"all_links,omitempty"`
	AllDomainLinks         *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks `json:"all_domain_links,omitempty" url:"all_domain_links,omitempty"`
	Nlp                    map[string]interface{}                                       `json:"nlp,omitempty" url:"nlp,omitempty"`
	Id                     string                                                       `json:"id" url:"id"`
	Score                  float64                                                      `json:"score" url:"score"`
	SimilarDocuments       []*SimilarDocument                                           `json:"similar_documents,omitempty" url:"similar_documents,omitempty"`
	CustomTags             map[string]interface{}                                       `json:"custom_tags,omitempty" url:"custom_tags,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ArticleResult) GetTitle() string {
	if a == nil {
		return ""
	}
	return a.Title
}

func (a *ArticleResult) GetAuthor() *string {
	if a == nil {
		return nil
	}
	return a.Author
}

func (a *ArticleResult) GetAuthors() *Authors {
	if a == nil {
		return nil
	}
	return a.Authors
}

func (a *ArticleResult) GetJournalists() *Journalists {
	if a == nil {
		return nil
	}
	return a.Journalists
}

func (a *ArticleResult) GetPublishedDate() *string {
	if a == nil {
		return nil
	}
	return a.PublishedDate
}

func (a *ArticleResult) GetPublishedDatePrecision() *string {
	if a == nil {
		return nil
	}
	return a.PublishedDatePrecision
}

func (a *ArticleResult) GetUpdatedDate() *string {
	if a == nil {
		return nil
	}
	return a.UpdatedDate
}

func (a *ArticleResult) GetUpdatedDatePrecision() *string {
	if a == nil {
		return nil
	}
	return a.UpdatedDatePrecision
}

func (a *ArticleResult) GetParseDate() *string {
	if a == nil {
		return nil
	}
	return a.ParseDate
}

func (a *ArticleResult) GetLink() string {
	if a == nil {
		return ""
	}
	return a.Link
}

func (a *ArticleResult) GetDomainUrl() string {
	if a == nil {
		return ""
	}
	return a.DomainUrl
}

func (a *ArticleResult) GetFullDomainUrl() string {
	if a == nil {
		return ""
	}
	return a.FullDomainUrl
}

func (a *ArticleResult) GetNameSource() *string {
	if a == nil {
		return nil
	}
	return a.NameSource
}

func (a *ArticleResult) GetIsHeadline() *string {
	if a == nil {
		return nil
	}
	return a.IsHeadline
}

func (a *ArticleResult) GetPaidContent() *bool {
	if a == nil {
		return nil
	}
	return a.PaidContent
}

func (a *ArticleResult) GetExtractionData() string {
	if a == nil {
		return ""
	}
	return a.ExtractionData
}

func (a *ArticleResult) GetCountry() *string {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *ArticleResult) GetRights() *string {
	if a == nil {
		return nil
	}
	return a.Rights
}

func (a *ArticleResult) GetRank() int {
	if a == nil {
		return 0
	}
	return a.Rank
}

func (a *ArticleResult) GetMedia() *string {
	if a == nil {
		return nil
	}
	return a.Media
}

func (a *ArticleResult) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *ArticleResult) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ArticleResult) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *ArticleResult) GetTitleTranslatedEn() *string {
	if a == nil {
		return nil
	}
	return a.TitleTranslatedEn
}

func (a *ArticleResult) GetContentTranslatedEn() *string {
	if a == nil {
		return nil
	}
	return a.ContentTranslatedEn
}

func (a *ArticleResult) GetWordCount() *int {
	if a == nil {
		return nil
	}
	return a.WordCount
}

func (a *ArticleResult) GetIsOpinion() *bool {
	if a == nil {
		return nil
	}
	return a.IsOpinion
}

func (a *ArticleResult) GetTwitterAccount() *string {
	if a == nil {
		return nil
	}
	return a.TwitterAccount
}

func (a *ArticleResult) GetAllLinks() *DtoResponsesMoreLikeThisResponseArticleResultAllLinks {
	if a == nil {
		return nil
	}
	return a.AllLinks
}

func (a *ArticleResult) GetAllDomainLinks() *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks {
	if a == nil {
		return nil
	}
	return a.AllDomainLinks
}

func (a *ArticleResult) GetNlp() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Nlp
}

func (a *ArticleResult) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *ArticleResult) GetScore() float64 {
	if a == nil {
		return 0
	}
	return a.Score
}

func (a *ArticleResult) GetSimilarDocuments() []*SimilarDocument {
	if a == nil {
		return nil
	}
	return a.SimilarDocuments
}

func (a *ArticleResult) GetCustomTags() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.CustomTags
}

func (a *ArticleResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArticleResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ArticleResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArticleResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArticleResult) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Authors struct {
	StringList []string
	String     string

	typ string
}

func NewAuthorsFromStringList(value []string) *Authors {
	return &Authors{typ: "StringList", StringList: value}
}

func NewAuthorsFromString(value string) *Authors {
	return &Authors{typ: "String", String: value}
}

func (a *Authors) GetStringList() []string {
	if a == nil {
		return nil
	}
	return a.StringList
}

func (a *Authors) GetString() string {
	if a == nil {
		return ""
	}
	return a.String
}

func (a *Authors) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		a.typ = "StringList"
		a.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typ = "String"
		a.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a Authors) MarshalJSON() ([]byte, error) {
	if a.typ == "StringList" || a.StringList != nil {
		return json.Marshal(a.StringList)
	}
	if a.typ == "String" || a.String != "" {
		return json.Marshal(a.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type AuthorsVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (a *Authors) Accept(visitor AuthorsVisitor) error {
	if a.typ == "StringList" || a.StringList != nil {
		return visitor.VisitStringList(a.StringList)
	}
	if a.typ == "String" || a.String != "" {
		return visitor.VisitString(a.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

// Cluster DTO class.
type Cluster struct {
	ClusterId   string                   `json:"cluster_id" url:"cluster_id"`
	ClusterSize int                      `json:"cluster_size" url:"cluster_size"`
	Articles    []map[string]interface{} `json:"articles,omitempty" url:"articles,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Cluster) GetClusterId() string {
	if c == nil {
		return ""
	}
	return c.ClusterId
}

func (c *Cluster) GetClusterSize() int {
	if c == nil {
		return 0
	}
	return c.ClusterSize
}

func (c *Cluster) GetArticles() []map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Articles
}

func (c *Cluster) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cluster) UnmarshalJSON(data []byte) error {
	type unmarshaler Cluster
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Cluster(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Cluster) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// ClusteringSearchResponse DTO class.
type ClusteringSearchResponse struct {
	Status        *string                `json:"status,omitempty" url:"status,omitempty"`
	TotalHits     int                    `json:"total_hits" url:"total_hits"`
	Page          int                    `json:"page" url:"page"`
	TotalPages    int                    `json:"total_pages" url:"total_pages"`
	PageSize      int                    `json:"page_size" url:"page_size"`
	ClustersCount int                    `json:"clusters_count" url:"clusters_count"`
	Clusters      []*Cluster             `json:"clusters,omitempty" url:"clusters,omitempty"`
	UserInput     map[string]interface{} `json:"user_input,omitempty" url:"user_input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ClusteringSearchResponse) GetStatus() *string {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *ClusteringSearchResponse) GetTotalHits() int {
	if c == nil {
		return 0
	}
	return c.TotalHits
}

func (c *ClusteringSearchResponse) GetPage() int {
	if c == nil {
		return 0
	}
	return c.Page
}

func (c *ClusteringSearchResponse) GetTotalPages() int {
	if c == nil {
		return 0
	}
	return c.TotalPages
}

func (c *ClusteringSearchResponse) GetPageSize() int {
	if c == nil {
		return 0
	}
	return c.PageSize
}

func (c *ClusteringSearchResponse) GetClustersCount() int {
	if c == nil {
		return 0
	}
	return c.ClustersCount
}

func (c *ClusteringSearchResponse) GetClusters() []*Cluster {
	if c == nil {
		return nil
	}
	return c.Clusters
}

func (c *ClusteringSearchResponse) GetUserInput() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.UserInput
}

func (c *ClusteringSearchResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClusteringSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClusteringSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClusteringSearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClusteringSearchResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks struct {
	StringList []string
	String     string

	typ string
}

func NewDtoResponsesAuthorSearchResponseArticleResultAllDomainLinksFromStringList(value []string) *DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks {
	return &DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks{typ: "StringList", StringList: value}
}

func NewDtoResponsesAuthorSearchResponseArticleResultAllDomainLinksFromString(value string) *DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks {
	return &DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks{typ: "String", String: value}
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks) GetStringList() []string {
	if d == nil {
		return nil
	}
	return d.StringList
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		d.typ = "StringList"
		d.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typ = "String"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks) MarshalJSON() ([]byte, error) {
	if d.typ == "StringList" || d.StringList != nil {
		return json.Marshal(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return json.Marshal(d.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesAuthorSearchResponseArticleResultAllDomainLinksVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks) Accept(visitor DtoResponsesAuthorSearchResponseArticleResultAllDomainLinksVisitor) error {
	if d.typ == "StringList" || d.StringList != nil {
		return visitor.VisitStringList(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return visitor.VisitString(d.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesAuthorSearchResponseArticleResultAllLinks struct {
	StringList []string
	String     string

	typ string
}

func NewDtoResponsesAuthorSearchResponseArticleResultAllLinksFromStringList(value []string) *DtoResponsesAuthorSearchResponseArticleResultAllLinks {
	return &DtoResponsesAuthorSearchResponseArticleResultAllLinks{typ: "StringList", StringList: value}
}

func NewDtoResponsesAuthorSearchResponseArticleResultAllLinksFromString(value string) *DtoResponsesAuthorSearchResponseArticleResultAllLinks {
	return &DtoResponsesAuthorSearchResponseArticleResultAllLinks{typ: "String", String: value}
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllLinks) GetStringList() []string {
	if d == nil {
		return nil
	}
	return d.StringList
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllLinks) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllLinks) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		d.typ = "StringList"
		d.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typ = "String"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtoResponsesAuthorSearchResponseArticleResultAllLinks) MarshalJSON() ([]byte, error) {
	if d.typ == "StringList" || d.StringList != nil {
		return json.Marshal(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return json.Marshal(d.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesAuthorSearchResponseArticleResultAllLinksVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (d *DtoResponsesAuthorSearchResponseArticleResultAllLinks) Accept(visitor DtoResponsesAuthorSearchResponseArticleResultAllLinksVisitor) error {
	if d.typ == "StringList" || d.StringList != nil {
		return visitor.VisitStringList(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return visitor.VisitString(d.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks struct {
	StringList []string
	String     string

	typ string
}

func NewDtoResponsesMoreLikeThisResponseArticleResultAllDomainLinksFromStringList(value []string) *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks {
	return &DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks{typ: "StringList", StringList: value}
}

func NewDtoResponsesMoreLikeThisResponseArticleResultAllDomainLinksFromString(value string) *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks {
	return &DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks{typ: "String", String: value}
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks) GetStringList() []string {
	if d == nil {
		return nil
	}
	return d.StringList
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		d.typ = "StringList"
		d.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typ = "String"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks) MarshalJSON() ([]byte, error) {
	if d.typ == "StringList" || d.StringList != nil {
		return json.Marshal(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return json.Marshal(d.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinksVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinks) Accept(visitor DtoResponsesMoreLikeThisResponseArticleResultAllDomainLinksVisitor) error {
	if d.typ == "StringList" || d.StringList != nil {
		return visitor.VisitStringList(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return visitor.VisitString(d.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesMoreLikeThisResponseArticleResultAllLinks struct {
	StringList []string
	String     string

	typ string
}

func NewDtoResponsesMoreLikeThisResponseArticleResultAllLinksFromStringList(value []string) *DtoResponsesMoreLikeThisResponseArticleResultAllLinks {
	return &DtoResponsesMoreLikeThisResponseArticleResultAllLinks{typ: "StringList", StringList: value}
}

func NewDtoResponsesMoreLikeThisResponseArticleResultAllLinksFromString(value string) *DtoResponsesMoreLikeThisResponseArticleResultAllLinks {
	return &DtoResponsesMoreLikeThisResponseArticleResultAllLinks{typ: "String", String: value}
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllLinks) GetStringList() []string {
	if d == nil {
		return nil
	}
	return d.StringList
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllLinks) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllLinks) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		d.typ = "StringList"
		d.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typ = "String"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DtoResponsesMoreLikeThisResponseArticleResultAllLinks) MarshalJSON() ([]byte, error) {
	if d.typ == "StringList" || d.StringList != nil {
		return json.Marshal(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return json.Marshal(d.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DtoResponsesMoreLikeThisResponseArticleResultAllLinksVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (d *DtoResponsesMoreLikeThisResponseArticleResultAllLinks) Accept(visitor DtoResponsesMoreLikeThisResponseArticleResultAllLinksVisitor) error {
	if d.typ == "StringList" || d.StringList != nil {
		return visitor.VisitStringList(d.StringList)
	}
	if d.typ == "String" || d.String != "" {
		return visitor.VisitString(d.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

// FailedSearchResponse DTO class.
type FailedSearchResponse struct {
	Status     *string                `json:"status,omitempty" url:"status,omitempty"`
	TotalHits  *int                   `json:"total_hits,omitempty" url:"total_hits,omitempty"`
	Page       *int                   `json:"page,omitempty" url:"page,omitempty"`
	TotalPages *int                   `json:"total_pages,omitempty" url:"total_pages,omitempty"`
	PageSize   *int                   `json:"page_size,omitempty" url:"page_size,omitempty"`
	Articles   []*ArticleResult       `json:"articles,omitempty" url:"articles,omitempty"`
	UserInput  map[string]interface{} `json:"user_input,omitempty" url:"user_input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FailedSearchResponse) GetStatus() *string {
	if f == nil {
		return nil
	}
	return f.Status
}

func (f *FailedSearchResponse) GetTotalHits() *int {
	if f == nil {
		return nil
	}
	return f.TotalHits
}

func (f *FailedSearchResponse) GetPage() *int {
	if f == nil {
		return nil
	}
	return f.Page
}

func (f *FailedSearchResponse) GetTotalPages() *int {
	if f == nil {
		return nil
	}
	return f.TotalPages
}

func (f *FailedSearchResponse) GetPageSize() *int {
	if f == nil {
		return nil
	}
	return f.PageSize
}

func (f *FailedSearchResponse) GetArticles() []*ArticleResult {
	if f == nil {
		return nil
	}
	return f.Articles
}

func (f *FailedSearchResponse) GetUserInput() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.UserInput
}

func (f *FailedSearchResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FailedSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FailedSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FailedSearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FailedSearchResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HttpValidationError) GetDetail() []*ValidationError {
	if h == nil {
		return nil
	}
	return h.Detail
}

func (h *HttpValidationError) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Journalists struct {
	StringList []string
	String     string

	typ string
}

func NewJournalistsFromStringList(value []string) *Journalists {
	return &Journalists{typ: "StringList", StringList: value}
}

func NewJournalistsFromString(value string) *Journalists {
	return &Journalists{typ: "String", String: value}
}

func (j *Journalists) GetStringList() []string {
	if j == nil {
		return nil
	}
	return j.StringList
}

func (j *Journalists) GetString() string {
	if j == nil {
		return ""
	}
	return j.String
}

func (j *Journalists) UnmarshalJSON(data []byte) error {
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		j.typ = "StringList"
		j.StringList = valueStringList
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		j.typ = "String"
		j.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, j)
}

func (j Journalists) MarshalJSON() ([]byte, error) {
	if j.typ == "StringList" || j.StringList != nil {
		return json.Marshal(j.StringList)
	}
	if j.typ == "String" || j.String != "" {
		return json.Marshal(j.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", j)
}

type JournalistsVisitor interface {
	VisitStringList([]string) error
	VisitString(string) error
}

func (j *Journalists) Accept(visitor JournalistsVisitor) error {
	if j.typ == "StringList" || j.StringList != nil {
		return visitor.VisitStringList(j.StringList)
	}
	if j.typ == "String" || j.String != "" {
		return visitor.VisitString(j.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", j)
}

// SearchResponse DTO class.
type SearchResponse struct {
	Status     *string                  `json:"status,omitempty" url:"status,omitempty"`
	TotalHits  int                      `json:"total_hits" url:"total_hits"`
	Page       int                      `json:"page" url:"page"`
	TotalPages int                      `json:"total_pages" url:"total_pages"`
	PageSize   int                      `json:"page_size" url:"page_size"`
	Articles   []map[string]interface{} `json:"articles,omitempty" url:"articles,omitempty"`
	UserInput  map[string]interface{}   `json:"user_input,omitempty" url:"user_input,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchResponse) GetStatus() *string {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SearchResponse) GetTotalHits() int {
	if s == nil {
		return 0
	}
	return s.TotalHits
}

func (s *SearchResponse) GetPage() int {
	if s == nil {
		return 0
	}
	return s.Page
}

func (s *SearchResponse) GetTotalPages() int {
	if s == nil {
		return 0
	}
	return s.TotalPages
}

func (s *SearchResponse) GetPageSize() int {
	if s == nil {
		return 0
	}
	return s.PageSize
}

func (s *SearchResponse) GetArticles() []map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Articles
}

func (s *SearchResponse) GetUserInput() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.UserInput
}

func (s *SearchResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// SimilarDocument DTO class.
type SimilarDocument struct {
	Id    string  `json:"id" url:"id"`
	Score float64 `json:"score" url:"score"`
	Title string  `json:"title" url:"title"`
	Link  string  `json:"link" url:"link"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SimilarDocument) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SimilarDocument) GetScore() float64 {
	if s == nil {
		return 0
	}
	return s.Score
}

func (s *SimilarDocument) GetTitle() string {
	if s == nil {
		return ""
	}
	return s.Title
}

func (s *SimilarDocument) GetLink() string {
	if s == nil {
		return ""
	}
	return s.Link
}

func (s *SimilarDocument) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SimilarDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler SimilarDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SimilarDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SimilarDocument) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty" url:"loc,omitempty"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValidationError) GetLoc() []*ValidationErrorLocItem {
	if v == nil {
		return nil
	}
	return v.Loc
}

func (v *ValidationError) GetMsg() string {
	if v == nil {
		return ""
	}
	return v.Msg
}

func (v *ValidationError) GetType() string {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *ValidationError) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	String  string
	Integer int

	typ string
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typ: "String", String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typ: "Integer", Integer: value}
}

func (v *ValidationErrorLocItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *ValidationErrorLocItem) GetInteger() int {
	if v == nil {
		return 0
	}
	return v.Integer
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typ = "Integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Integer" || v.Integer != 0 {
		return json.Marshal(v.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Integer" || v.Integer != 0 {
		return visitor.VisitInteger(v.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}
